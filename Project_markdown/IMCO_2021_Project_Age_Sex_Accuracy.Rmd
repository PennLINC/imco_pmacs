---
title: "IMCO 2021 Project - Age, Sex, and Accuracy"
author: "Erica Baller"
date: "3/16/2021"
output:
  word_document: default
 # html_document: default
params:
  args: myarg
---

```{r setup, include=TRUE}
#install.packages("knitr")
#library(knitr)
knitr::opts_chunk$set(echo = TRUE)

### Set up your paths
#homedir = '/Users/eballer/BBL/imco/pmacs/PMACS_remote'
homedir = '/project/imco'
mydirec = '/baller'
subListPath = '/subjectLists'
scriptsPath = '/scripts'

## include external functions
source(paste0(homedir, mydirec, scriptsPath, '/imco_functions.R'))

```

## IMCO Project

Welcome to IMCO 2021! This project is a culmination of many years of work and a beautiful collaboration between Ted Satterthwaite and Taki Shinohara. Its many iterations have taken us from structural to functional data, chead to pmacs, fsl to freesurfer to R to matlab. Many trainees have been a part of the project, including Lauren Beard, Ali Valcarcel, Kristin Linn, Tinashe Tapera. This last (and final) round of analyses has been run by Erica Baller, with incredible support from Azeez Adebimpe. A big thank you to Bart Larsen for advising on modeling, and Adam Pines for his tireless help with taking my graphics to the next level. Thank you to Val Sydnor and Jakob Seidlitz for providing maps for our fancier visualization. In the remaining part of this document, I will take you on a step by step journey through the analysis, code, and visualizations. I'll provide the code as well as the image it produced for me so you can double check it. Enjoy!


Git for this project can be found at: https://github.com/PennLINC/imco_pmacs

Lab notebook (with day by day documentation): 

Erica Baller local computer and github script: Replicating_LB_2D_imco_started_20200911.Rmd

** Notes before you get started **

 1) Please make sure you have appropriately specified your home directory above
 
 2) Please make sure to **xbash** 
 
 3) After that, things should run just fine

To run this from command line ** on PMACS**: 

```{bash run_markdown, eval=FALSE}
xbash #you must do this first!!!
Rscript -e "rmarkdown::render('/project/imco/baller/Project_markdown/IMCO_2021_Project_Age_Sex_Accuracy.Rmd')"
```

  

---

### IMCO Analysis overview

This project was started on 20200911 

IMCO, or intermodal coupling (or "coupling"), was a project that begun in 2018 and has had numerous data anaylists/managers on the project. It is based on work by Simon 's work in 2016 (Paper: Vandekar, S. N., Shinohara, R. T., Raznahan, A., Hopson, R. D., Roalf, D. R., Ruparel, K., … Satterthwaite, T. D. (2016). Subject-level Measurement of Local Cortical Coupling. NeuroImage, 133, 88–97.), which looked at the relationship between cortical thickness and sulcal depth, and demonstrated regional differences, non-linear trajectories, as well as sex differences. His work used surface gray matter maps. The general process was the brain was divided into vertices and a neighborhood around each vertex was defined. For each neighborhood, the relationship between cortical thickness and sulcal depth was calculated using local weighted regression, with a variety of covariates. 

In 2018, Lauren Beard replicated this work, studying cbf (ASL) with ALFF (rs-fmri). This was all done in 2D at the surface. Ali and Kristin then developed a 3D method (using volumes rather than surface), but ran into significant partial volume effects given white matter flanking edges of GM. As such, we have decided to move forward with Lauren Beard's main analyses in 2D (surface) space.

The steps for coupling are as follows - 

1) Sample construction
2) Taking each subject's alff and cbf voxelwise maps and projecting to the surface 
    - In fsaverage5 space (10242 vertices per hemisphere). Image type: .mgh
3) Running the locally weighted regression to obtain 1 coupling map per hemisphere per person (each person will end up with a left and right hemisphere map). Image type: .mgh
4) Converting these .mgh files to .asc
5) Reading in the .asc files into R, as well as demographic and accuracy information, and running coupling ~ age, sex, motion, and accuracy regressions
6) Correcting and masking these findings for display
7) Displaying in matlab
8) Spin testing gam sex and lm accuracy results to test whether # vertices per yeo network is significantly different in these analysis
9) Plotting the spin test results

Extra analyses were performed to test whether coupling related to other measures like metabolic consumption of glucose, allometric scaling, etc. These are available for reference but were not used in the final analysis.

Coupling was initially completed on chead, and replicated by Azeez using updated freesurfer and R directories. Once we verified that the coupling maps were equivalent to the original maps created in 2018, we moved the maps over to PMACS and started our group level analyses from there. 

For reference, I have included the wikis used to make the maps on chead can be found below. The first part of this script will also run through **exactly** what we did to set up pmacs from chead. The second part will go through pmacs code and will hopefully run directly from this markdown.


#####                               Part 1 - from chead to PMACS 

---

**Relevant Coupling Wikis from chead, all written by Lauren Beard:**

  1) how to generate 2D coupling maps: https://github.com/PennBBL/tutorials/wiki/Surface-Coupling
 
  2) CBF-ALFF specifically (single subject): https://github.com/PennBBL/imcoScripts/wiki/Rest-CBF-Coupling
 
     *Links to* https://github.com/PennBBL/tutorials/wiki/3D-Volume-to-Surface-Projection-(FS)
     
  3) group analysis: https://github.com/PennBBL/imcoScripts/wiki/AlffCbf-RehoCbf-GLM-Summary

  4) Vertex wise group analysis:  https://github.com/PennBBL/tutorials/wiki/FreeSurfer-Vertex-Wise-Group-Level-Analyses
  
  5) results: https://github.com/PennBBL/imcoScripts/blob/master/alffCbf_rehoCbf_effects_20180607%20(1).pdf
 
*** Be aware that there are a few steps left out of these wikis, including some manual moving of files from one format to another that makes running this coupling in series impossible. That being said, once we tracked everything down, we verified that the files are correct.

---

 **In order to do this, Azeez did/confirmed the following:**

  - Step 1) Surface projection
    + Surface projection scripts worked (vol2surf)
    + One step to consider adding to the end of the projection scrips is a change in the names of the files. Coupling needs files names rh.cbf rather than rh.cbf.mgh (which is what comes out of surface projection)
    + To accomplish this, a simple: cp rh.cbf.mgh rh.cbf works just fine
    + Azeez okay with me adding this last piece to the projection scripts themselves so it does not have to be done manually
  
  - Step 2) Coupling (to write to a user specified directory rather than frozen) *all done in bash, this code can be directly copied)
```{bash azeez_replication, eval=FALSE}
 mkdir /data/jag/aadebimpe/subjecdir #make your own directory
 cp -r /data/joy/BBL/studies/pnc/processedData/structural/freesurfer53/99991 . #copy one subject
 cp -r /data/joy/BBL/studies/pnc/processeddata/structural/freesurfer53/fsaverage5 . #copy fsaverage5 directory locally
 cd /data/jux/BBL/projects/coupling/imcoScripts/surfCoupling/R
 Rscript coupling_v2.R -h
```
  
    
  - Step 3) Make sure you change these files in coupling_v2.R
```{r coupling_v2_changes, eval=FALSE}
  ## check these specifications are correct
   # -m MEASURES cbf,alff - 
   # -t fsaverage5
   # -fwhm 15

  ##make these directory changes 
  scripts="/data/joag/aadebimpe/surfCoupling/R" #this contains the coupling_v2.R and kth_neighbor_v3.R, change full path for kth_neightbor script
  export SUBJECT_DIR=/data/jag/aadebimpe/subjecdir #this is the directory you make
```

  - Step 4) Change SUBJECT_DIR in bash profile
```{bash change_bash_profile, eval=FALSE}
gedit ~/.bash_profile
export SUBJECT_DIR=/data/jag/aadebimpe/subjecdir #this is the directory you make
```
  
---

--- 

**Location of files on chead **

    - Surface projection maps in chead: /data/jux/BBL/projects/coupling/surfaceMaps/<alff,cbf,reho>

    - Coupling surface maps: /data/jux/BBL/projects/coupling/couplingSurfaceMaps/<alffCbf,cbfAlff,cbfReho,rehoCbf>
    
    - LB's directory was scp'ed directly to pmacs (with each item in <> run separately:
        + from chead:
```{bash copy, eval=FALSE}

#Each were done separately: couplingMaps,couplingSurfaceMaps,fsGLM,imcoScripts,subjectsLists,surfaceMaps
 scp -r /data/jux/BBL/projects/coupling/<couplingMaps,couplingSurfaceMaps,fsGLM,imcoScripts,subjectsLists,surfaceMaps> eballer@transfer.pmacs.upenn.edu:/project/imco/old_amv_and_lb_direcs/from_lb/coupling/. 

```
        
       
---

##### Setting up PMACS

**From chead, there is a script to move data. Everything else done on PMACS: ** /data/jux/BBL/projects/coupling/coupling_test_eb_20200918/code/to_move
    - This can be sourced in bash. It contains the following commands:

```{bash move_files, eval=FALSE}

scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/neuroimaging/asl/n1601_PcaslQaData_20170403.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/neuroimaging/asl/.
scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/neuroimaging/rest/n1601_RestQAData_20170714.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/neuroimaging/rest/.
scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/neuroimaging/t1struct/n1601_t1QaData_20170306.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/neuroimaging/t1struct/.
scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/clinical/n1601_goassess_itemwise_bifactor_scores_20161219.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/clinical/.
scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/health/n1601_health_20170421.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/health/.
scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/demographics/n1601_demographics_go1_20161212.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/demographics/.
scp /data/joy/BBL/studies/pnc/n1601_dataFreeze/cnb/n1601_cnb_factor_scores_tymoore_20151006.csv eballer@transfer.pmacs.upenn.edu:/project/imco/pnc/cnb/.
scp /data/jux/BBL/projects/coupling/imcoScripts/restCbf/n831_alff_cbf_makeSample.R eballer@transfer.pmacs.upenn.edu:/project/imco/baller/scripts/
scp /data/jux/BBL/projects/coupling/subjectsLists/n1601_bblid_datexscanid.csv eballer@transfer.pmacs.upenn.edu:/project/imco/baller/subjectLists/.
scp /data/jux/BBL/projects/coupling/subjectsLists/n831_imageOrder.csv eballer@transfer.pmacs.upenn.edu:/project/imco/baller/subjectLists/.
scp /data/jux/BBL/projects/coupling/coupling_test_eb_20200918/code/restCbf_R/make_831x10242_matrices.R eballer@transfer.pmacs.upenn.edu:/project/imco/baller/scripts/.    

```


---

#####                               Part 2 - On PMACS

For this next section, I'll walk you through sample construction, analysis, and visualization. Scripts are found in **/project/imco/baller/scripts**. Code will be embeded and runnable where able. Links to code will also be embedded. One challenge of PMACS is needing to initialize a bunch of libraries so you can run matlab, rstudio, etc. I start off by initializing these libraries.

```{bash initialize_libraries, eval=FALSE}
cd /project/imco/baller/scripts
xbash
source load_matlab
source load_rstudio
```

  
**Sample Construction **

*script: /project/imco/baller/scripts/from_chead/n831_alff_cbf_makeSample.R*

Code: 
```{r make_sample}
###########################################
#### PMACS Adapted sample construction ####
###########################################

## Replicated LB sample construction from 2018 ##
#### Date: 01/14/2021
###### Author: Erica Baller

### pre: pnc QA, health, demographics files: 

# 1) /project/imco/pnc/neuroimaging/asl/n1601_PcaslQaData_20170403.csv
# 2) /project/imco/pnc/neuroimaging/rest/n1601_RestQAData_20170714.csv
# 3) /project/imco/pnc/neuroimaging/t1struct/n1601_t1QaData_20170306.csv
# 4) /project/imco/pnc/health/n1601_health_20170421.csv
# 5) /project/imco/pnc/demographics/n1601_demographics_go1_20161212.csv

### post: 

# 1) final sample .csv [/project/imco/baller/subjectLists/n831_alff_cbf_finalSample.csv]
# 2) image order .csv [/project/imco/baller/subjectLists/n831_alff_cbf_finalSample_imageOrder.csv]

### uses:

## This script takes the PNC 1601 sample, and goes through a variety of exclusions to get the final n. 
# 1) removes subjects with poor QA data (t1Exclude, pcaslVoxelwiseExclude, restExcludeVoxelwise
# 2) uses ltnExcludev2 for health - "Particiapants with no medical co-morbidity, abnormal brain structure on radiology read, or current use of psychoactive medications (Excludes those with medical rating 3/4, major incidental findings that distort anatomy, psychoactive medical and psych medications, inpatient hospitalizations)"   1=Yes; 0=No     Calculated Field using data from goassess       A few medications that were previously missed or not categorized in the right medical class were updated on 10/4/16 that resulted in version change.

## It then factorizes race and sex, and adds a new column datexscanid - this is great because some subjects have multiple scans

### dependencies: Any R should do. We used 3.2.5

###########set homedir so you can use local or remote
#1) set homedir before you run this
#2) set my_path to be your own path

#homedir = '/Users/eballer/BBL/imco/pmacs/PMACS_remote'
#homedir = '/project/imco'
#mydirec = '/baller/subjectLists'

# Load in files 
pcaslQA <- read.csv(paste0(homedir, "/pnc/neuroimaging/asl/n1601_PcaslQaData_20170403.csv"))
restQA <- read.csv(paste0(homedir, "/pnc/neuroimaging/rest/n1601_RestQAData_20170714.csv"))
t1QA <- read.csv(paste0(homedir, "/pnc/neuroimaging/t1struct/n1601_t1QaData_20170306.csv"))
healthQA <- read.csv(paste0(homedir, "/pnc/health/n1601_health_20170421.csv"))
demos <- read.csv(paste0(homedir, "/pnc/demographics/n1601_demographics_go1_20161212.csv"))

#these two are premade, do not need to be done for r, but do need to be done for fsGLM, can be commented out
datexscan <- read.csv(paste0(homedir, mydirec, subListPath, "/n1601_bblid_datexscanid.csv"))
order <- read.csv(paste0(homedir, mydirec, subListPath, "/n831_imageOrder.csv"))

#merge
df <- merge(t1QA, healthQA, by = "bblid")
df <- merge(df, pcaslQA, by = c("bblid"))
df <- merge(df, restQA, by = c("bblid", "scanid"))
df <- merge(df, demos, by = "bblid")
df <- merge(df, datexscan, by = "bblid")

#do excludions
df_exclude <- df[which(df$t1Exclude == 0),] #n=1540, lost 61
df_exclude <- df_exclude[which(df_exclude$restExcludeVoxelwise == 0),] #n = 1090, lost 450
df_exclude <- df_exclude[which(df_exclude$pcaslVoxelwiseExclude == 0),] #n = 1036, lost 54
final <- df_exclude[which(df_exclude$ltnExcludev2 == 0),] #n = 831, lost 205


## Clean demos
final$ageAtScan1 <- (final$ageAtScan1)/12
final$sex <- as.factor(final$sex)
final$race <- as.factor(final$race)
final$race2 <- as.factor(final$race2)
final <- subset(final, select = -(scanid.y))
names(final)[names(final) == "scanid.x"] <- "scanid"

# Get correct image order for GLM
finalOrdered <- merge(order,final,by=c("bblid","datexscanid")) #only if you want to do this

# Write out final demos for sample
write.csv(final, paste0(homedir, mydirec, subListPath, "/n831_alff_cbf_finalSample_erica_sampling.csv"), row.names=FALSE, quote = FALSE) #added
write.csv(finalOrdered,paste0(homedir, mydirec, subListPath, "/n831_alff_cbf_finalSample_imageOrder_erica_sampling.csv"),row.names=FALSE, quote = FALSE)

#LB's initial exclusions were a little more involved (more lines, but still accurate). I redid these for simplicity's sake, and for the ability to know how many we lost at each step. The original version is still present in the R script /project/imco/baller/scripts/from_chead/n831_alff_cbf_makeSample.R

#for the analysis, we used the following subject lists - 
#/n831_alff_cbf_finalSample_sampling.csv"
#n831_alff_cbf_finalSample_imageOrder_sampling.csv
```

Demographics summary 
```{r make_demographics_table}
make_demographics_table(finalOrdered)
```

Mean Coupling results
```{r mean_coupling_Ts}
#set home directory, switch this depending on whether running from PMACS or from home directory
#homedir <- "/Users/eballer/BBL/imco/pmacs/PMACS_remote/"
#homedir <- "/project/imco/"

thresh = 3.09

#read in maps
lh_mean_map <- read.csv(paste0(homedir, "/baller/results/mean_maps/n831_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5.asc"), header = F)
rh_mean_map <- read.csv(paste0(homedir, "/baller/results/mean_maps/n831_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5.asc"), header = F)

#bind them together
overall_mean_map <- rbind(lh_mean_map, rh_mean_map)

#take the mean of the T values
mean_t <- mean(overall_mean_map$V1)

#convert the T to p - one-sided
p.value = pt(q=mean_t, df=(length(overall_mean_map$V1) - 1), lower.tail = FALSE)
print(p.value)

#threshold at 3.09 (p < 0.001)
lh_mean_map_thresh_boolean <- ifelse(abs(lh_mean_map$V1) < thresh, 0, 1)
lh_mean_map_thresh <- lh_mean_map_thresh_boolean * lh_mean_map$V1

rh_mean_map_thresh_boolean <- ifelse(abs(rh_mean_map$V1) < thresh, 0, 1)
rh_mean_map_thresh <- rh_mean_map_thresh_boolean * rh_mean_map$V1

#save
write.table(x=lh_mean_map_thresh, file = paste0(homedir, "/baller/results/mean_maps/n831_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5_THRESH_3.09.csv"), quote = F, row.names = F, col.names = F)
write.table(x=rh_mean_map_thresh, file = paste0(homedir, "/baller/results/mean_maps/n831_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5_THRESH_3.09.csv"), quote = F, row.names = F, col.names = F)
```

**Coupling regressions **

This needs to be bsubbed unfortunately, so cannot be run directly from here. As such, it is wrapped.

To run: 
```{bash run_coupling, eval=FALSE}

cd /project/imco/baller/scripts/coupling
xbash
source coupling_accuracy_fx_T_bsub.sh

```

    
    
 *script: /project/imco/baller/scripts/coupling/coupling_accuracy_fx_T_bsub.sh* 
 
```{bash bsub, eval=FALSE}
bsub -o /project/imco/baller/scripts/coupling/logfiles/outputlogjob.out -e /project/imco/baller/scripts/coupling/logfiles/outputlogjob.error -R "rusage[mem=128G]" < /project/imco/baller/scripts/coupling/coupling_accuracy_fx_T_wrapper.sh
```
 
 *script: /project/imco/baller/scripts/coupling/coupling_accuracy_fx_T_wrapper.sh* 
```{bash wrapper, eval=FALSE}
#!/bin/bash
echo LSB_JOB_REPORT_MAIL=N >> ~/.bashrc
Rscript coupling_accuracy_fx_T.R
```

 *script: /project/imco/baller/scripts/coupling/coupling_accuracy_fx_T.R* 
```{r coupling_analysis, eval=FALSE}
##################################################
### Accuracy Scripts 02/09/2021 ###
##################################################

####################
##### Summary ######
####################

#input: asc files, and pnc demographics, cnb, clinical files
#output: 10242 length vector csvs with T and/or p values for vertex-wide regression
#uses: goes vertex by vertex and does regression (coupling by age, sex, cognition, etc), pulls out T and p from these values and sticks it in a vector. The vector can then be used for visualization in matlab
#dependencies: R (3.6.3 is my current default in pmacs)

## 20210401 - Realized the gam for accuracy should be different. Removed the sex term, and changed the pull of the right values
####################
###  Libraries   ###
####################

library(mgcv)
library(dplyr)
library(ggplot2)
library(visreg)

#####################################################################################
####              Makes the 831x10242 matrices, both left and right              ####
#####################################################################################

#set home directory, switch this depending on whether running from PMACS or from home directory
#homedir <- "/Users/eballer/BBL/imco/pmacs/PMACS_remote/"
homedir <- "/project/imco/"

# read in demos
subjDemos <- read.csv(paste0(homedir, "/baller/subjectLists/n831_alff_cbf_finalSample_imageOrder.csv"))

#some verification preprocessing
subjDemos$sex <- as.factor(subjDemos$sex)
subjDemos$race <- as.factor(subjDemos$race)
subjDemos$race2 <- as.factor(subjDemos$race2)

#add osex category for use in gam later
subjDemos$osex <- ordered(subjDemos$sex)

#add psych bifactor scores
psych <- read.csv(paste0(homedir, "/pnc/clinical/n1601_goassess_itemwise_bifactor_scores_20161219.csv"), header = TRUE)

#remove 4factorv2 from title
names(psych) <-gsub("_4factorv2", "", names(psych))

#merge
subjDemos <- merge(subjDemos, psych, by = "bblid")

#cognitive data
cog <- read.csv(paste0(homedir, "/pnc/cnb/n1601_cnb_factor_scores_tymoore_20151006.csv"))
accuracy <- subset(cog, select = c("bblid", 
                                   "Overall_Accuracy", 
                                   "F1_Exec_Comp_Res_Accuracy", 
                                   "F2_Social_Cog_Accuracy", 
                                   "F3_Memory_Accuracy"))
#merge
subjDemos <- merge(subjDemos, accuracy, by = "bblid")

#drop the scanid.y
subjDemos <- subset(subjDemos, select = -scanid.y)

#rename scanid.x to scanid
names(subjDemos) <- gsub("scanid.x", "scanid", names(subjDemos)) 

#make list of bblid/scanid
bblid_scanid <- paste0(subjDemos$bblid, "_", subjDemos$datexscanid)

#####################
##### Left Side #####
#####################

#initiate matrix for storage
numrows <- dim(subjDemos)[1]
lh_matrix <- matrix(nrow = numrows, ncol = 10242)

#go through each subject, grab 5th column in asc, transpose and stick in matrix
# output is 831 x 10242 matrix
for (subj in 1:831) {
  
  bblid <- subjDemos$bblid[subj]
  datexscanid <- subjDemos$datexscanid[subj]
  file_path <- paste0(homedir, "/couplingSurfaceMaps/alffCbf/lh/stat/", bblid, "_", datexscanid, "_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5.asc")
  alff_data <- read.table(file_path, stringsAsFactors = FALSE)
  lh_matrix[subj,] <- t(alff_data$V5)
  
}

#append with demographics
subjDemos_with_lh_matrix <- cbind(subjDemos, lh_matrix)

#write output
write.table(subjDemos_with_lh_matrix, file = paste0(homedir, "/baller/results/coupling_accuracy/subjDemos_with_lh_", numrows, "x10242.csv"), sep = ",")

#####################
#### Right Side #####
#####################
#initiate matrix for storage
numrows <- dim(subjDemos)[1]
rh_matrix <- matrix(nrow = numrows, ncol = 10242)

#go through each subject, grab 5th column in asc, transpose and stick in matrix
# output is 831 x 10242 matrix
for (subj in 1:831) {
  
  bblid <- subjDemos$bblid[subj]
  datexscanid <- subjDemos$datexscanid[subj]
  file_path <- paste0(homedir, "/couplingSurfaceMaps/alffCbf/rh/stat/", bblid, "_", datexscanid, "_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5.asc")
  alff_data <- read.table(file_path, stringsAsFactors = FALSE)
  rh_matrix[subj,] <- t(alff_data$V5)
  
}

#append with demographics
subjDemos_with_rh_matrix <- cbind(subjDemos, rh_matrix)

#write output
write.table(subjDemos_with_rh_matrix, file = paste0(homedir, "/baller/results/coupling_accuracy/subjDemos_with_rh_", numrows, "x10242.csv"), sep = ",")


####-----------------------------------------------------------------------------####
####---------------------------End of Part 1- Making matrices---_----------------####
####-----------------------------------------------------------------------------####

#####################################################################################
####                   Run regression, both left and right                       ####
#####################################################################################

#make easier to reference names
lh_alff <- subjDemos_with_lh_matrix #can also read directly from files if you'd like
rh_alff <- subjDemos_with_rh_matrix


#####################################################
#                       lm/gams                     #
#####################################################

#initialize vectors for models

hemis <- c("lh", "rh") #hemispheres
models <- c("age", "sex", "accuracy", "exec_accuracy", "soc_accuracy", "mem_accuracy")

coeffs <- c("p", "t") #p or t value
corrs <- c("uncor", "fdr") #correction

for (hemi in hemis){
  for (model in models) {
    for (coeff in coeffs) {
      for (corr in corrs) {
        vector_init_cmd <- paste0(hemi, "_gam_", model, "_", coeff, "_", corrs, " <- vector(length = 10242)")
        print(vector_init_cmd)
        eval(parse(text=as.name(vector_init_cmd)))
      }
    }
  }
}


#make linear models as well
#lm_models <- c("age", "accuracy", "speed", "efficiency")
lm_models <- c("age", "sex", "accuracy", "exec_accuracy", "soc_accuracy", "mem_accuracy")
for (hemi in hemis) {
  for (model in lm_models) {
    for (coeff in coeffs) {
      for (corr in corrs) {
        vector_init_cmd <- paste0(hemi, "_lm_", model, "_", coeff, "_", corrs, "<- vector(length= 10242)")
        eval(parse(text=as.name(vector_init_cmd)))
      }
    }
  }
}


#######################
######## Left #########
#######################

#get # of items in df for calculation of column)
numcolumns <- dim(lh_alff)[2]
#run gams models and store info in respective vectors
for (i in 1:10242) {
  curcol = (numcolumns - 10242 + i) # will start you counting at the right part of the df
  age_sex_model <- gam(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                         osex + s(ageAtScan1, k = 4, fx = T), data=lh_alff)
  
  ## accuracy
  accuracy_model <- gam(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                          osex + s(ageAtScan1, k = 4, fx = T) + Overall_Accuracy, data=lh_alff)
  
  exec_accuracy_model <- gam(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                               osex + s(ageAtScan1, k = 4, fx = T) + F1_Exec_Comp_Res_Accuracy, data=lh_alff)
  
  soc_accuracy_model <- gam(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                              osex + s(ageAtScan1, k = 4, fx = T) + F2_Social_Cog_Accuracy, data=lh_alff)
  
  mem_accuracy_model <- gam(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                              osex + s(ageAtScan1, k = 4, fx = T) + F3_Memory_Accuracy, data=lh_alff)
  
  
  
  #lm
  age_lm_model <- lm(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1, 
                     data=lh_alff)
  sex_lm_model <- lm(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + osex, 
                     data=lh_alff)
  
  ## acc
  accuracy_lm_model <- lm(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + Overall_Accuracy, 
                          data=lh_alff)
  
  exec_accuracy_lm_model <- lm(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + F1_Exec_Comp_Res_Accuracy, 
                               data=lh_alff)
  
  soc_accuracy_lm_model <- lm(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + F2_Social_Cog_Accuracy, 
                              data=lh_alff)
  
  mem_accuracy_lm_model <- lm(lh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + F3_Memory_Accuracy, 
                              data=lh_alff)
  
  
  #put pvalue in it's appropriate lm
  lh_gam_age_p_uncor[i] <- summary(age_sex_model)$s.table[1,4] #smooth term for ageAtScan1
  lh_gam_sex_p_uncor[i] <- summary(age_sex_model)$p.table[4,4] #linear term
  
  lh_gam_accuracy_p_uncor[i] <- summary(accuracy_model)$p.table[5,4] #accuracy term
  lh_gam_exec_accuracy_p_uncor[i] <- summary(exec_accuracy_model)$p.table[5,4] #accuracy term
  lh_gam_soc_accuracy_p_uncor[i] <- summary(soc_accuracy_model)$p.table[5,4] #accuracy term
  lh_gam_mem_accuracy_p_uncor[i] <- summary(mem_accuracy_model)$p.table[5,4] #accuracy term
  
  #lm to assess directionality
  lh_lm_age_p_uncor[i] <- summary(age_lm_model)$coeff[4,4]
  lh_lm_sex_p_uncor[i] <- summary(sex_lm_model)$coeff[4,4]
  
  lh_lm_accuracy_p_uncor[i] <- summary(accuracy_lm_model)$coeff[5,4]
  lh_lm_exec_accuracy_p_uncor[i] <- summary(exec_accuracy_lm_model)$coeff[5,4]
  lh_lm_soc_accuracy_p_uncor[i] <- summary(soc_accuracy_lm_model)$coeff[5,4]
  lh_lm_mem_accuracy_p_uncor[i] <- summary(mem_accuracy_lm_model)$coeff[5,4]
  
  #put tvalue in it's appropriate lm
  lh_gam_age_t_uncor[i] <- summary(age_sex_model)$s.table[1,3] #smooth term for ageAtScan1
  lh_gam_sex_t_uncor[i] <- summary(age_sex_model)$p.table[4,3] #linear term
  
  lh_gam_accuracy_t_uncor[i] <- summary(accuracy_model)$p.table[5,3] #accuracy term
  lh_gam_exec_accuracy_t_uncor[i] <- summary(exec_accuracy_model)$p.table[5,3] #accuracy term
  lh_gam_soc_accuracy_t_uncor[i] <- summary(soc_accuracy_model)$p.table[5,3] #accuracy term
  lh_gam_mem_accuracy_t_uncor[i] <- summary(mem_accuracy_model)$p.table[5,3] #accuracy term
  
  #lm to assess directionality
  lh_lm_age_t_uncor[i] <- summary(age_lm_model)$coeff[4,3]
  lh_lm_sex_t_uncor[i] <- summary(sex_lm_model)$coeff[4,3] #linear term
  
  lh_lm_accuracy_t_uncor[i] <- summary(accuracy_lm_model)$coeff[5,3]
  lh_lm_exec_accuracy_t_uncor[i] <- summary(exec_accuracy_lm_model)$coeff[5,3]
  lh_lm_soc_accuracy_t_uncor[i] <- summary(soc_accuracy_lm_model)$coeff[5,3]
  lh_lm_mem_accuracy_t_uncor[i] <- summary(mem_accuracy_lm_model)$coeff[5,3]
  
}

#####################
###### RIGHT ########
#####################
#get # of items in df for calculation of column)
numcolumns <- dim(rh_alff)[2]
#run gams models and store info in respective vectors
for (i in 1:10242) {
  curcol = (numcolumns - 10242 + i) # will start you counting at the right part of the df
  age_sex_model <- gam(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                         osex + s(ageAtScan1, k = 4, fx = T), data=rh_alff)
  
  ## accuracy
  accuracy_model <- gam(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                          osex + s(ageAtScan1, k = 4, fx = T) + Overall_Accuracy, data=rh_alff)
  
  exec_accuracy_model <- gam(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                               osex + s(ageAtScan1, k = 4, fx = T) + F1_Exec_Comp_Res_Accuracy, data=rh_alff)
  
  soc_accuracy_model <- gam(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                              osex + s(ageAtScan1, k = 4, fx = T) + F2_Social_Cog_Accuracy, data=rh_alff)
  
  mem_accuracy_model <- gam(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion +
                              osex + s(ageAtScan1, k = 4, fx = T) + F3_Memory_Accuracy, data=rh_alff)
  
  
  
  #lm
  age_lm_model <- lm(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1, 
                     data=rh_alff)
  sex_lm_model <- lm(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + osex, 
                     data=rh_alff)
  
  ## acc
  accuracy_lm_model <- lm(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + Overall_Accuracy, 
                          data=rh_alff)
  
  exec_accuracy_lm_model <- lm(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + F1_Exec_Comp_Res_Accuracy, 
                               data=rh_alff)
  
  soc_accuracy_lm_model <- lm(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + F2_Social_Cog_Accuracy, 
                              data=rh_alff)
  
  mem_accuracy_lm_model <- lm(rh_alff[,curcol] ~ pcaslRelMeanRMSMotion + restRelMeanRMSMotion + ageAtScan1 + F3_Memory_Accuracy, 
                              data=rh_alff)
  
  
  #put pvalue in it's appropriate lm
  rh_gam_age_p_uncor[i] <- summary(age_sex_model)$s.table[1,4] #smooth term for ageAtScan1
  rh_gam_sex_p_uncor[i] <- summary(age_sex_model)$p.table[4,4] #linear term
  
  rh_gam_accuracy_p_uncor[i] <- summary(accuracy_model)$p.table[5,4] #accuracy term
  rh_gam_exec_accuracy_p_uncor[i] <- summary(exec_accuracy_model)$p.table[5,4] #accuracy term
  rh_gam_soc_accuracy_p_uncor[i] <- summary(soc_accuracy_model)$p.table[5,4] #accuracy term
  rh_gam_mem_accuracy_p_uncor[i] <- summary(mem_accuracy_model)$p.table[5,4] #accuracy term
  
  #lm to assess directionality
  rh_lm_age_p_uncor[i] <- summary(age_lm_model)$coeff[4,4]
  rh_lm_sex_p_uncor[i] <- summary(sex_lm_model)$coeff[4,4]
  
  rh_lm_accuracy_p_uncor[i] <- summary(accuracy_lm_model)$coeff[5,4]
  rh_lm_exec_accuracy_p_uncor[i] <- summary(exec_accuracy_lm_model)$coeff[5,4]
  rh_lm_soc_accuracy_p_uncor[i] <- summary(soc_accuracy_lm_model)$coeff[5,4]
  rh_lm_mem_accuracy_p_uncor[i] <- summary(mem_accuracy_lm_model)$coeff[5,4]
  
  #put tvalue in it's appropriate lm
  rh_gam_age_t_uncor[i] <- summary(age_sex_model)$s.table[1,3] #smooth term for ageAtScan1
  rh_gam_sex_t_uncor[i] <- summary(age_sex_model)$p.table[4,3] #linear term
  
  rh_gam_accuracy_t_uncor[i] <- summary(accuracy_model)$p.table[5,3] #accuracy term
  rh_gam_exec_accuracy_t_uncor[i] <- summary(exec_accuracy_model)$p.table[5,3] #accuracy term
  rh_gam_soc_accuracy_t_uncor[i] <- summary(soc_accuracy_model)$p.table[5,3] #accuracy term
  rh_gam_mem_accuracy_t_uncor[i] <- summary(mem_accuracy_model)$p.table[5,3] #accuracy term
  
  #lm to assess directionality
  rh_lm_age_t_uncor[i] <- summary(age_lm_model)$coeff[4,3]
  rh_lm_sex_t_uncor[i] <- summary(sex_lm_model)$coeff[4,3] #linear term
  
  rh_lm_accuracy_t_uncor[i] <- summary(accuracy_lm_model)$coeff[5,3]
  rh_lm_exec_accuracy_t_uncor[i] <- summary(exec_accuracy_lm_model)$coeff[5,3]
  rh_lm_soc_accuracy_t_uncor[i] <- summary(soc_accuracy_lm_model)$coeff[5,3]
  rh_lm_mem_accuracy_t_uncor[i] <- summary(mem_accuracy_lm_model)$coeff[5,3]
  
}





#################################################################################
#################################################################################

#####################################################
#                     results                       #
#####################################################

#### FDR correction ####
for (hemi in hemis) {
  for (model in models) {
    hemi_model_p_unc <- paste0(hemi, "_gam_", model, "_p_uncor") 
    hemi_model_p_fdr <- paste0(hemi, "_gam_", model, "_p_fdr")    
    
    print(hemi_model_p_unc)
    
    #correct p values
    pfdr <- eval(substitute(p.adjust(i, method="fdr"), list(i = as.name(hemi_model_p_unc))))
    
    #figure out which values are < 0.05 and add to pfdr matrix
    pfdr <- as.data.frame(pfdr)
    pfdr$sig <- ifelse(pfdr<0.05, 1, 0)
    pfdr$sig_noNA <- ifelse(is.na(pfdr$sig), 0, pfdr$sig)
    names(pfdr) <- c("pfdr", "sig05", "sig05_noNA")
    hemi_model_p_fdr <- as.data.frame(pfdr[,1]) #sig05
    
    
    
    #multiply T values by fdr vector to get the list of Ts that are fdr corrected
    hemi_model_t_unc <- paste0(hemi, "_gam_", model, "_t_uncor")
    hemi_model_t_fdr <- paste0(hemi, "_gam_", model, "_t_fdr")
    t_df <- eval(substitute(as.data.frame(i), list(i = as.name(hemi_model_t_unc))))
    names(t_df) <- c("tval")
    t_df$tfdr <- pfdr[,3] * t_df$tval
    hemi_model_t_fdr <- as.data.frame(t_df[,2])
    
    
    #######################
    #### write tables #####
    #######################
    
    ## uncorrected ##
    
    ### p
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi_model_p_unc, ".csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_p_unc, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
    ### t
    
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi_model_t_unc, ".csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_t_unc, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
    ## corrected ##
    
    ### p
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi, "_gam_", model, "_p_fdr05.csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_p_fdr, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
    ### t
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi, "_gam_", model, "_t_fdr05.csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_t_fdr, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
  }
}

######  linear model alone #####

#### FDR correction ####
for (hemi in hemis) {
  for (model in lm_models) {
    hemi_model_p_unc <- paste0(hemi, "_lm_", model, "_p_uncor") 
    hemi_model_p_fdr <- paste0(hemi, "_lm_", model, "_p_fdr")    
    
    print(hemi_model_p_unc)
    
    #correct p values
    pfdr <- eval(substitute(p.adjust(i, method="fdr"), list(i = as.name(hemi_model_p_unc))))
    
    #figure out which values are < 0.05 and add to pfdr matrix
    pfdr <- as.data.frame(pfdr)
    pfdr$sig <- ifelse(pfdr<0.05, 1, 0)
    pfdr$sig_noNA <- ifelse(is.na(pfdr$sig), 0, pfdr$sig)
    names(pfdr) <- c("pfdr", "sig05", "sig05_noNA")
    hemi_model_p_fdr <- as.data.frame(pfdr[,1]) #sig05
    
    
    
    #multiply T values by fdr vector to get the list of Ts that are fdr corrected
    hemi_model_t_unc <- paste0(hemi, "_lm_", model, "_t_uncor")
    hemi_model_t_fdr <- paste0(hemi, "_lm_", model, "_t_fdr")
    t_df <- eval(substitute(as.data.frame(i), list(i = as.name(hemi_model_t_unc))))
    names(t_df) <- c("tval")
    t_df$tfdr <- pfdr[,3] * t_df$tval
    hemi_model_t_fdr <- as.data.frame(t_df[,2])
    
    
    #######################
    #### write tables #####
    #######################
    
    ## uncorrected ##
    
    ### p
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi_model_p_unc, ".csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_p_unc, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
    ### t
    
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi_model_t_unc, ".csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_t_unc, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
    ## corrected ##
    
    ### p
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi, "_lm_", model, "_p_fdr05.csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_p_fdr, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
    
    ### t
    filename <- paste0(homedir, "/baller/results/coupling_accuracy/", hemi, "_lm_", model, "_t_fdr05.csv")
    write_table_command <- paste0("write.table(x = ", hemi_model_t_fdr, ", file = \"", filename,"\", row.names = FALSE, col.names = FALSE)")
    eval(parse(text=write_table_command))
  }
}

###########
## Plots ##
###########


### Find Gam age FDR corrected
### just for age
lh_gam_age_t_fdr05 <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/lh_gam_age_t_fdr05.csv'), header = F)
rh_gam_age_t_fdr05 <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/rh_gam_age_t_fdr05.csv'), header = F)

#turn 0s into na
lh_gam_to_keep <- lh_gam_age_t_fdr05$V1
lh_gam_to_keep[lh_gam_to_keep==0] <- NA

rh_gam_to_keep <- rh_gam_age_t_fdr05$V1
rh_gam_to_keep[rh_gam_to_keep==0] <- NA

#concatenate rows to keep
lh_and_rh_to_keep <- c(lh_gam_to_keep, rh_gam_to_keep)
columns_to_drop <- which(is.na(lh_and_rh_to_keep))

# concatenate 831x10242 right and left matrices, and drop the columns with NA
lh_and_rh_matrix <- data.frame(cbind(lh_matrix, rh_matrix))
lh_and_rh_matrix_fdr_corrected = subset(lh_and_rh_matrix, select = -(columns_to_drop)) 

lh_and_rh_rowmeans <- rowMeans(lh_and_rh_matrix_fdr_corrected) #make vector of row means
age = subjDemos$ageAtScan1
#age_x2_for_plotting <- c(subjDemos$ageAtScan1, subjDemos$ageAtScan1) #make vector of ages

#plot and save
jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_fdr.jpg'))
plot(age, lh_and_rh_rowmeans, ylab = "Coupling (Z)", xlab = "Age (In Years)", main = "Mean Coupling by Age")
abline(lm(lh_and_rh_rowmeans~age), col = 'red')
dev.off()

### Find Gam age uncorrected
### just for age
lh_gam_age_t_uncor <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/lh_gam_age_t_uncor.csv'), header = F)
rh_gam_age_t_uncor <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/rh_gam_age_t_uncor.csv'), header = F)

#turn 0s into na
lh_gam_to_keep <- lh_gam_age_t_uncor$V1
lh_gam_to_keep[lh_gam_to_keep==0] <- NA

rh_gam_to_keep <- rh_gam_age_t_uncor$V1
rh_gam_to_keep[rh_gam_to_keep==0] <- NA

#concatenate rows to keep
lh_and_rh_to_keep <- c(lh_gam_to_keep, rh_gam_to_keep)
columns_to_drop <- which(is.na(lh_and_rh_to_keep))

# concatenate 831x10242 right and left matrices, and drop the columns with NA
lh_and_rh_matrix <- data.frame(cbind(lh_matrix, rh_matrix))
lh_and_rh_matrix_uncorrected = subset(lh_and_rh_matrix, select = -(columns_to_drop)) 

lh_and_rh_rowmeans <- rowMeans(lh_and_rh_matrix_uncorrected) #make vector of row means
age = subjDemos$ageAtScan1
#age_x2_for_plotting <- c(subjDemos$ageAtScan1, subjDemos$ageAtScan1) #make vector of ages

#plot and save
jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_uncor.jpg'))
plot(age, lh_and_rh_rowmeans, ylab = "Coupling (Z)", xlab = "Age (In Years)", main = "Mean Coupling by Age")
abline(lm(lh_and_rh_rowmeans~age), col = 'red')
dev.off()

#visreg
jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_uncor_visreg.jpg'))
df <- data.frame(cbind(lh_and_rh_rowmeans, age))
names(df) <- c("Means", "Age")
fit <- lm(Means~Age, data=df)
visreg(fit, "Age")
dev.off()

```

Plots for Age x Coupling including GAM
*script: /project/imco/baller/scripts/coupling/scatter_plots.R*

*make sure you install.packages("devtools")

```{r scatter_plots, eval=FALSE}
###########
## Plots ##
###########


###pre: gam age results, both fdr and uncorrected. rh and lh matrices
###post: jpegs of linear and gam modesl
###uses: makes the scatter plot of age by couping means for Figure 2
### dependencies: R 3.6.3

library(mgcv)
library(dplyr)
library(ggplot2)
library(visreg)

#set home directory, switch this depending on whether running from PMACS or from home directory
#homedir <- "/Users/eballer/BBL/imco/pmacs/PMACS_remote/"
#homedir <- "/project/imco/"

numrows = 831


# read in lh and rh matrices, which have demos appended
lh_df <- read.table(paste0(homedir, "/baller/results/coupling_accuracy/subjDemos_with_lh_", numrows, "x10242.csv"), sep = ",")
rh_df <- read.table(paste0(homedir, "/baller/results/coupling_accuracy/subjDemos_with_rh_", numrows, "x10242.csv"), sep = ",")

#just get the coupling values
lh_matrix <- lh_df[,(dim(lh_df)[2]-10241):dim(lh_df)[2]]
rh_matrix <- rh_df[,(dim(rh_df)[2]-10241):dim(rh_df)[2]]

### Find Gam age FDR corrected
### just for age
lh_gam_age_t_fdr05 <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/lh_gam_age_t_fdr05.csv'), header = F)
rh_gam_age_t_fdr05 <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/rh_gam_age_t_fdr05.csv'), header = F)

#turn 0s into na
lh_gam_to_keep <- lh_gam_age_t_fdr05$V1
lh_gam_to_keep[lh_gam_to_keep==0] <- NA

rh_gam_to_keep <- rh_gam_age_t_fdr05$V1
rh_gam_to_keep[rh_gam_to_keep==0] <- NA

#concatenate rows to keep
lh_and_rh_to_keep <- c(lh_gam_to_keep, rh_gam_to_keep)
columns_to_drop <- which(is.na(lh_and_rh_to_keep))

# concatenate 831x10242 right and left matrices, and drop the columns with NA
lh_and_rh_matrix <- data.frame(cbind(lh_matrix, rh_matrix))
lh_and_rh_matrix_fdr_corrected = subset(lh_and_rh_matrix, select = -(columns_to_drop)) 

lh_and_rh_rowmeans <- rowMeans(lh_and_rh_matrix_fdr_corrected) #make vector of row means
age = lh_df$ageAtScan1

#plot and save
jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_fdr05.jpg'))
plot(age, lh_and_rh_rowmeans, ylab = "Coupling (Z)", xlab = "Age (In Years)", main = "Mean Coupling by Age")
abline(lm(lh_and_rh_rowmeans~age), col = 'red')
dev.off()

#visreg

jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_fdr05_visreg.jpg'))
fit <- lm(Means~Age, data=df)
visreg(fit, "Age", ylab = "Mean Coupling (Z)", xlab = "Age (in Years)",
       line=list(col="red"),
       points=list(col="black"))
dev.off()

jpeg(paste0(homedir, 'baller/results/images/Mean_coupling_by_age_rplot_fdr05_visreg_gam.jpg'))
fit_gam <- gam(Means~s(Age, k = 4, fx=T), data=df)
visreg(fit_gam, "Age", ylab = "Mean Coupling (Z)", xlab = "Age (in Years)",
       line=list(col="red"),
       points=list(col="black"))
dev.off()

#################
## Derivatives ##
#################
d<-derivatives(fit_gam,n=1000)
d_plot <- draw(d)
print(d_plot)
ggsave(plot = d_plot,filename = paste0(homedir, "baller/results/images/derivative_plot_age_gam_fdr_corrected.png"),device = "png",width = 180,height = 120,units = "mm")

d<- d %>%
  mutate(sig = !(0 >lower & 0 < upper)) #Ages where the CI does not include zero
cat(sprintf("\nSignificant change: %1.2f - %1.2f\n",min(d$data[d$sig==T]),max(d$data[d$sig==T]))) #this only work

######



### Find Gam age uncorrected
### just for age
lh_gam_age_t_uncor <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/lh_gam_age_t_uncor.csv'), header = F)
rh_gam_age_t_uncor <- read.csv(paste0(homedir, '/baller/results/coupling_accuracy/rh_gam_age_t_uncor.csv'), header = F)

#turn 0s into na
lh_gam_to_keep <- lh_gam_age_t_uncor$V1
lh_gam_to_keep[lh_gam_to_keep==0] <- NA

rh_gam_to_keep <- rh_gam_age_t_uncor$V1
rh_gam_to_keep[rh_gam_to_keep==0] <- NA

#concatenate rows to keep
lh_and_rh_to_keep <- c(lh_gam_to_keep, rh_gam_to_keep)
columns_to_drop <- which(is.na(lh_and_rh_to_keep))

# concatenate 831x10242 right and left matrices, and drop the columns with NA
lh_and_rh_matrix <- data.frame(cbind(lh_matrix, rh_matrix))
lh_and_rh_matrix_uncorrected = subset(lh_and_rh_matrix, select = -(columns_to_drop)) 

lh_and_rh_rowmeans <- rowMeans(lh_and_rh_matrix_uncorrected) #make vector of row means
age = lh_df$ageAtScan1
#age_x2_for_plotting <- c(subjDemos$ageAtScan1, subjDemos$ageAtScan1) #make vector of ages

#plot and save
jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_uncor.jpg'))
plot(age, lh_and_rh_rowmeans, ylab = "Coupling (Z)", xlab = "Age (In Years)", main = "Mean Coupling by Age")
abline(lm(lh_and_rh_rowmeans~age), col = 'red')
dev.off()

#visreg
df <- data.frame(cbind(lh_and_rh_rowmeans, age))
names(df) <- c("Means", "Age")

jpeg(paste0(homedir,'baller/results/images/Mean_coupling_by_age_rplot_uncor_visreg.jpg'))
fit <- lm(Means~Age, data=df)
visreg(fit, "Age", ylab = "Mean Coupling (Z)", xlab = "Age (in Years)",
       line=list(col="red"),
       points=list(col="black"))
dev.off()

jpeg(paste0(homedir, 'baller/results/images/Mean_coupling_by_age_rplot_uncor_visreg_gam.jpg'))
fit_gam <- gam(Means~s(Age, k = 4, fx=T), data=df)
visreg(fit_gam, "Age", ylab = "Mean Coupling (Z)", xlab = "Age (in Years)",
       line=list(col="red"),
       points=list(col="black"))
dev.off()

######## Deriatives ########
d<-derivatives(fit_gam,n=1000)
d_plot <- draw(d)
print(d_plot)
ggsave(plot = d_plot,filename = paste0(homedir, "baller/results/images/derivative_plot_age_gam_uncorrected.png"),device = "png",width = 180,height = 120,units = "mm")

d<- d %>%
  mutate(sig = !(0 >lower & 0 < upper)) #Ages where the CI does not include zero
cat(sprintf("\nSignificant change: %1.2f - %1.2f\n",min(d$data[d$sig==T]),max(d$data[d$sig==T])))


```
First derivative spline (fdr corrected): 

<img width="100%" src="/project/imco/baller/results/images/derivative_plot_age_gam_fdr_corrected.png"/>


##### Extra- Part 3- repeating these analyses for CBF and ALFF alone 
Similar to above, navigate to appropriate directory and run the code
```{bash run_alff, eval=FALSE}

cd /project/imco/baller/scripts/alff
xbash
source alff_accuracy_fx_T_bsub.sh

```

```{bash run_cbf, eval=FALSE}

cd /project/imco/baller/scripts/cbf
xbash
source cbf_accuracy_fx_T_bsub.sh

```

It is not too hard to add extra analyses
  1) Make sure you include additional columns in the first part where you are selecting columns to include
  2) Update the gam and lm loop variables
  3) Make sure within the loops you specific the new models you'd like
 
**Making extra files for visualization (including yeo network maps or glycolysis maps) **  

As part of our analysis, I wanted to make extra maps that allowed me to see the overlap between our fdr corrected values and well known masks (yeo, GI, cmrglu). I developed the script below. It runs fast and creates tons of masks that you can look at.


```{r convert_Ts_to_parcels_for_display, eval=FALSE}
################################
## 2/19/2021 Convert Parcels ###
################################

################################
#### Author: Erica Baller ######
################################

### This script emerged out of the desire to take vertex output and display it within different networks/parcels

#pre: input: 
#1) a vector(n=10242) of T values, with 0s indicating vertices you don't want to include
#- the default is to make maps for ALL interesting analyses (coupling, alff, cbf; lm and gam; uncor and fdr05 corrected). 
#If you would like to change it, please do so in the following section by commenting out:
#analyses <- c("coupling_accuracy", "cbf_accuracy", "alff_accuracy") 
#models <- c("gam_age", "lm_age", "lm_sex", "lm_accuracy", "lm_exec_accuracy")
#corrs <- c("uncor", "fdr05") #correction
#2) mask vectors
#a) lh and rh 10242 matrices with the vertex #s
#b) the ID number matrix (length = 7 for Yeo7)
#c) the names of the networks (length = 7 for Yeo7)
#3) this is optional second mask (or masks), I am running through all options so I don't have to rewrite the script
   #- if you do not want the other masks, set it to FALSE. If you would like to change which masks they are, do so in the %masks line

#post: 
#1) a vector corresponding to the parcel value for the regions you want to display
#2) Optional - a vector corresponding to second map

#uses: 
#1) Will take the input vector, convert all non-zeros to 1s. 
#will also do this for positive and negative only, for better visualization
#2) will multiple this vector with the parcel assignment (or second mask)
#3) Will save output in chosen directory

#dependencies
#any R should do
#I am using PMACS, and R 3.2.5

### get arguments if needed
#args = commandArgs(trailingOnly=TRUE)

#### set # parcels in case I want to do 7 or 17 or something else in the future
parcel_type = "Yeo" 
parcel_num = 7 
input_parcel_array_length = 10242

##### Alternative second mask
make_second_mask_flag = TRUE #i.e. I want to make an additional mask(s)
second_mask_path = "/baller/processed_data/zaixu_maps/fsaverage5/"
masks = c("GI_fsaverage5_10242.csv", "AllometricScaling_fsaverage5.csv", "CMRGlu_fsaverage5.csv", "Hill2010_evo_fsaverage5.csv","MeanCBF.fsaverage5.csv")
mask_length = 10242

## set abs and relative paths. Must toggle before running locally/on cluster
#homedir <- "/Users/eballer/BBL/imco/pmacs/PMACS_remote"
#homedir <- "/project/imco"


#will loop through each of these
analyses <- c("coupling_accuracy", "cbf_accuracy", "alff_accuracy") 
models <- c("gam_age", "lm_age", "gam_sex", "lm_sex", "lm_accuracy", "lm_exec_accuracy")
corrs <- c("uncor", "fdr05") #correction



for (analysis in analyses) {
  for (model in models) {
    for (corr in corrs) {  
      
      ### set results path
      stat_path <- paste0("/", analysis, "/")
      print(stat_path)
      result_path <- paste0(model, "_t_", corr)
      print(result_path)
      
      ### set paths
      ## input
      lh_stat_map <- read.csv(paste0(homedir, "/baller/results/", stat_path, "lh_", result_path, ".csv"), header = F)
      rh_stat_map <- read.csv(paste0(homedir, "/baller/results/", stat_path, "rh_", result_path, ".csv"), header = F)
      
      parcelID <- read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/NetworkIDnumbers", parcel_type, parcel_num, ".csv"), header = F)
      parcelName <- t(read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/NetworkNames", parcel_type, parcel_num, ".csv"), header = F))
      
      lh_parcel_nums <- read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/lh_", input_parcel_array_length, "_vertex_nums_", parcel_type, parcel_num, ".csv"), header = F)
      rh_parcel_nums <- read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/rh_", input_parcel_array_length, "_vertex_nums_", parcel_type, parcel_num, ".csv"), header = F)
      
      ## output
      lh_outdir <- paste0(homedir, "/baller/results/", stat_path, "lh_", result_path, "_", parcel_type, parcel_num, ".csv")
      rh_outdir <- paste0(homedir, "/baller/results/", stat_path, "rh_", result_path, "_", parcel_type, parcel_num, ".csv")
      
      lh_outdir_pos <- paste0(homedir, "/baller/results/", stat_path, "lh_pos_", result_path, "_", parcel_type, parcel_num, ".csv")
      rh_outdir_pos <- paste0(homedir, "/baller/results/", stat_path, "rh_pos_", result_path, "_", parcel_type, parcel_num, ".csv")
      
      lh_outdir_neg <- paste0(homedir, "/baller/results/", stat_path, "lh_neg_", result_path, "_", parcel_type, parcel_num, ".csv")
      rh_outdir_neg <- paste0(homedir, "/baller/results/", stat_path, "rh_neg_", result_path, "_", parcel_type, parcel_num, ".csv")
      
      ### print output so you know what is going on
      
      print(paste0("Converting ", homedir, "/baller/results/", stat_path, "lh_", result_path, ".csv to ", parcel_type, parcel_num ))
      print("Of note, these are the parcel names and associated numbers")
      refnum_networknum_name <- cbind(parcelName, parcelID, 1:dim(parcelID)[1])
      names(refnum_networknum_name) <- c("Network_name", "Net_number", "Mapping_for_matlab_PBP")
      print(refnum_networknum_name)
      
      
      #convert stat map to boolean
      lh_stat_boolean <- ifelse(lh_stat_map == 0, 0, 1)
      rh_stat_boolean <- ifelse(rh_stat_map == 0, 0, 1)
      
      #positive and negative vectors
      lh_stat_boolean_pos <- ifelse(lh_stat_map > 0, 1, 0)
      rh_stat_boolean_pos <- ifelse(rh_stat_map > 0, 1, 0)
      
      lh_stat_boolean_neg <- ifelse(lh_stat_map < 0, 1, 0)
      rh_stat_boolean_neg <- ifelse(rh_stat_map < 0, 1, 0)
      
      #make a column of numbers for mapping
      parcelID$network_num <- c(1:dim(parcelID)[1])
      
      #add extra row to parcelID, not clear why this didn't come from Yeo labels, maybe cerebellum?... 8 will equal 65793
      # comment this out if not using yeo 
      parcelID<- rbind(parcelID, c(65793, 8))
      
      #make vector for lh and rh with mapping
      lh_numerical_map <- lh_parcel_nums
      rh_numerical_map <- rh_parcel_nums
      
      #foreach vertex, which contains a bunch of numbers, match it to the appropriate column, and take the network num (i.e. yeo 2, which would correspond to Motor), associated with it
      lh_numerical_map[] <- lapply(lh_parcel_nums, function(x) parcelID$network_num[match(x, parcelID$V1)])
      rh_numerical_map[] <- lapply(rh_parcel_nums, function(x) parcelID$network_num[match(x, parcelID$V1)])
      
      #multiply
      
      lh_stat_booleanxnetwork <- lh_stat_boolean * lh_numerical_map
      rh_stat_booleanxnetwork <- rh_stat_boolean * rh_numerical_map 
      
      lh_stat_booleanxnetwork_pos <- lh_stat_boolean_pos * lh_numerical_map
      rh_stat_booleanxnetwork_pos <- rh_stat_boolean_pos * rh_numerical_map 
      
      lh_stat_booleanxnetwork_neg <- lh_stat_boolean_neg * lh_numerical_map
      rh_stat_booleanxnetwork_neg <- rh_stat_boolean_neg * rh_numerical_map 
      
      
      #write output
      write.table(x = lh_stat_booleanxnetwork, file = lh_outdir, quote = F, row.names = F, col.names = F)
      write.table(x = rh_stat_booleanxnetwork, file = rh_outdir, quote = F, row.names = F, col.names = F)
      
      #write output
      write.table(x = lh_stat_booleanxnetwork_pos, file = lh_outdir_pos, quote = F, row.names = F, col.names = F)
      write.table(x = rh_stat_booleanxnetwork_pos, file = rh_outdir_pos, quote = F, row.names = F, col.names = F)
      
      #write output
      write.table(x = lh_stat_booleanxnetwork_neg, file = lh_outdir_neg, quote = F, row.names = F, col.names = F)
      write.table(x = rh_stat_booleanxnetwork_neg, file = rh_outdir_neg, quote = F, row.names = F, col.names = F)
      
      
      ##############################################
      ######### Optional Second Mask Code ##########
      ##############################################
      
      ##### Alternative second mask
      
      if (make_second_mask_flag == TRUE){
        for (mask in masks) {
          lh_mask_nums <- read.csv(paste0(homedir, second_mask_path, "lh.", mask), header = F)
          rh_mask_nums <- read.csv(paste0(homedir, second_mask_path, "rh.", mask), header = F)
          print(paste0(homedir, second_mask_path, "lh.", mask), header = F)
          print(paste0(homedir, second_mask_path, "rh.", mask), header = F)
        
          
          #output
          lh_outdir <- paste0(homedir, "/baller/results/", stat_path, "lh_", result_path, "_", mask, "_", mask_length, ".csv")
          rh_outdir <- paste0(homedir, "/baller/results/", stat_path, "rh_", result_path, "_", mask, "_", mask_length, ".csv")
          
          lh_outdir_pos <- paste0(homedir, "/baller/results/", stat_path, "lh_pos_", result_path, "_", mask, "_", mask_length, ".csv")
          rh_outdir_pos <- paste0(homedir, "/baller/results/", stat_path, "rh_pos_", result_path, "_", mask, "_", mask_length, ".csv")
          
          lh_outdir_neg <- paste0(homedir, "/baller/results/", stat_path, "lh_neg_", result_path, "_", mask, "_", mask_length, ".csv")
          rh_outdir_neg <- paste0(homedir, "/baller/results/", stat_path, "rh_neg_", result_path, "_", mask, "_", mask_length, ".csv")
          
          ## multiply
          lh_stat_booleanxnetwork <- lh_stat_boolean * lh_mask_nums
          rh_stat_booleanxnetwork <- rh_stat_boolean * rh_mask_nums
          
          lh_stat_booleanxnetwork_pos <- lh_stat_boolean_pos * lh_mask_nums
          rh_stat_booleanxnetwork_pos <- rh_stat_boolean_pos * rh_mask_nums 
          
          lh_stat_booleanxnetwork_neg <- lh_stat_boolean_neg * lh_mask_nums
          rh_stat_booleanxnetwork_neg <- rh_stat_boolean_neg * rh_mask_nums
          
          #write output
          write.table(x = lh_stat_booleanxnetwork, file = lh_outdir, quote = F, row.names = F, col.names = F)
          write.table(x = rh_stat_booleanxnetwork, file = rh_outdir, quote = F, row.names = F, col.names = F)
          
          #write output
          write.table(x = lh_stat_booleanxnetwork_pos, file = lh_outdir_pos, quote = F, row.names = F, col.names = F)
          write.table(x = rh_stat_booleanxnetwork_pos, file = rh_outdir_pos, quote = F, row.names = F, col.names = F)
          
          #write output
          write.table(x = lh_stat_booleanxnetwork_neg, file = lh_outdir_neg, quote = F, row.names = F, col.names = F)
          write.table(x = rh_stat_booleanxnetwork_neg, file = rh_outdir_neg, quote = F, row.names = F, col.names = F)
        }
        
      }
    }
  }
}



```



**Making actual visualization **

The visualizations are done in matlab, unfortunately, but I have made a bash script that can call matlab, so you no longer have to go into matlab and do it manually. Log in to PMACS, navigate to PBP_graphics directory, which contains all the scripts I have made to make pretty visualizations. This will get the right version of matlab for you as well. 

```{bash prepare_and_run_matlab, eval=FALSE}
cd /project/imco/baller/scripts/PBP_graphics
source ../load_matlab #contains the following line of code: bsub -Is -XF -q matlab_interactive 'bash'
sh run_visualization_scripts_from_command_line.sh

```

The actual code in run_visualization_scripts_from_command_line.sh is below:
```{bash run_visualization_scripts_from_command_line, eval=FALSE}
#!/bin/sh

##################################
### PBP visualizations Wrapper ###
##################################

###### Author: Erica Baller ######
######   Date: 2/26/2021    ######

## pre: commands_for_matlab (in same directory as PBP scripts
   #- contains all the commands we want to pass to matlab to run visualizations automaticall
## post: images in /project/imco/baller/results/images/pbp
## uses: I was getting tired of having to open matlab and run each of these commands manually. This script takes a bunch of commands and just feeds them to matlab, no muss, no fuss
## dependencies: Matlab 2020b, please run "source /project/imco/baller/scripts/load_matlab before starting this


#set directories
#homedir = '/project/imco'
#set homedir = '/Users/eballer/BBL/imco/pmacs/PMACS_remote/'
wking_dir='/baller/scripts/PBP_graphics'
command_file="$homedir/$wking_dir/commands_for_matlab"
echo $command_file

#initialize matlab


#######
### loop ###
while IFS= read -r line; do
        echo "$line"
        matlab -nosplash -nodesktop -nodisplay -r "$line; exit"

done < $command_file

```

The command files contain paths to the PBP* visualization scripts. At any time, you can run one or all of them by changing the inputs in /project/imco/baller/scripts/PBP_graphics/commands_for_matlab. Currently, these are the I recommend putting in that file. Of note, if you ever want to run a command independently, just go into matlab, copy the command, and run it within matlab. This just takes forever. Here are the final commands for visualization that I ran. 

```{bash commands_for_matlab_pbp, eval=FALSE}
PBP_vertWiseEffect_Erica_Ts_green_purp_imco_results_outpath('/project/imco/baller/results/mean_maps/n831_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5.csv','/project/imco/baller/results/mean_maps/n831_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5.csv','coupling_mean_fdr05_grpur')
PBP_vertWiseEffect_Erica_mean_coupling_plasma_results_outpath('/project/imco/baller/results/mean_maps/n831_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5_THRESH_3.09.csv','/project/imco/baller/results/mean_maps/n831_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5_THRESH_3.09.csv','coupling_mean_thresh_3_09_plasma')
PBP_vertWiseEffect_Erica_Ts_blue_alff_results_outpath('/project/imco/baller/results/mean_maps/lh_alff_mean.csv','/project/imco/baller/results/mean_maps/rh_alff_mean.csv','alff_mean_fdr05_blue')
PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/mean_maps/lh_cbf_mean.csv','/project/imco/baller/results/mean_maps/rh_cbf_mean.csv','cbf_mean_fdr05')
PBP_vertWiseEffect_Erica_gam_age_parula_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_with_lm_sign_age_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_with_lm_sign_age_t_fdr05.csv','coupling_gam_w_lm_sign_age_parula_fdr05_grey_mid')
PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_sex_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_sex_t_fdr05.csv','coupling_gam_sex_red_and_blue_fdr05')
PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_exec_accuracy_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_exec_accuracy_t_fdr05.csv','coupling_lm_exec_accuracy_red_and_blue_fdr05')
PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_exec_accuracy_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_exec_accuracy_t_fdr05.csv','coupling_gam_exec_accuracy_red_and_blue_fdr05')
```

Final images:

Coupling mean

<img width="100%" src="/project/imco/baller/results/images/pbp/coupling_mean_fdr05_grpur.png"/>


Coupling mean with plasma colors

<img width="100%" src="/project/imco/baller/results/images/pbp/coupling_mean_thresh_3_09_plasma.png"/>

Alff mean

<img width="100%" src="/project/imco/baller/results/images/pbp/alff_mean_fdr05_blue.png"/>

CBF mean
<img width="100%" src="/project/imco/baller/results/images/pbp/cbf_mean_fdr05.png"/>

Coupling gam age

<img width="100%" src="/project/imco/baller/results/images/pbp/coupling_gam_w_lm_sign_age_parula_fdr05.png"/>

Coupling gam sex

<img width="100%" src="/project/imco/baller/results/images/pbp/coupling_gam_sex_red_and_blue_fdr05.png"/>

Coupling lm exec accuracy

<img width="100%" src="/project/imco/baller/results/images/pbp/coupling_lm_exec_accuracy_red_and_blue_fdr05.png"/>

Coupling gam exec accuracy

<img width="100%" src="/project/imco/baller/results/images/pbp/coupling_gam_exec_accuracy_red_and_blue_fdr05.png"/>


Sample code (from PBP_vertWiseEffect_Erica_Ts_results_outpath.m)

```{bash this_is_actually_matlab_code, eval=FALSE}
function PBP_vertWiseEffect_Erica(LH,RH,name)% pretty picture code, AAB 4/2018 - AP 5/1/20 - Updated to threshold according to inp
ut - 1/12/21
% data should be vectors, 10242 in length if fsaverage5 is used
% if using higher resolution, then change accordingly
% depencies include: matlab freesrufer functions, subaxis.m (matlab central), inferno color scale (matlab central - for Sam ;)

%%% SET THRESHOLDS AS DESIRED HERE: only fill in each threshold as needed (no need to set both if you only want to threshold one e
nd)
% Values at or above this set to gray
 %Uthresh=-2;
% Values at or below this set to gray
 LThresh=2;
%%%


addpath(genpath('/appl/freesurfer-6.0.0/matlab/'));
addpath(genpath('/project/imco/baller/scripts/subaxis/'));
addpath(genpath('/project/imco/baller/scripts/Colormaps/Colormaps (5)/Colormaps/'));
%{
addpath(genpath('/cbica/projects/alpraz_EI/scripts/tools/'));
ProjectFolder = '/cbica/projects/pinesParcels/data/SingleParcellation';
SubjectsFolder = '/cbica/software/external/freesurfer/centos7/5.3.0/subjects/fsaverage5';
%}

plot_text='';
[vertices, faces] = freesurfer_read_surf('/project/imco/surfaces/fsaverage5/surf/lh.inflated');
%using lh.gray will make more anatomical looking plot but harder to see into sulci
right = readtable(RH,'TreatAsEmpty','NA','ReadVariableNames',false);
datar = table2array(right);
left = readtable(LH,'TreatAsEmpty','NA','ReadVariableNames',false);
datal = table2array(left);

%left=load(LHvec);
%right=load(RHvec);
%datal=left;
%datar=right;
minval = min(min(datal),min(datar)) %useful for colorbar later	

%set NaN to 0
%I generally have the midcut region set to NaN
%in the csv files that I read in
indexNaNrh = find(isnan(datar));
indexNaNlh = find(isnan(datal));
datar(indexNaNrh)=0;
datal(indexNaNlh)=0;
datalr=[datal; datar];
%invoke thresholding 1/12/21
if exist('Uthresh','Var') == 1;
	AboveThresh= datalr > Uthresh;
	datalr(AboveThresh)=0;
end
if exist('LThresh','Var') ==1;
	BelowThresh= datalr < LThresh;
	datalr(BelowThresh)=0;
end
%%% set color scale
% 1/12/21 - for p values, visualizing 1/p might be more effective. comment out line below and  uncomment subsequent line to nix th
is approach.
%datalr=1./datalr;


% 12/1/21 tiny bit of code to deal with 1/0 in matlab
InfIndex=find(datalr==Inf);
% Infinity values to 0
datalr(InfIndex)=0;

%AP% set to make white zero on all maps
maxabs=prctile(abs(datalr),88);
%mincol= minval-.00001 
%maxcol=maxabs
%mincol=-maxabs
maxcol=max(datalr)
mincol=min(datalr)
%change above to set max/min manually or by other means
%custommap=colormap('plasma'); %or whatever
% for white at 0
%custommap=colormap(b2r(-1,1));
%custommap=colormap('jet');
custommap=colormap('plasma')
custommap(1,:)=[0.75 0.75 0.75];


data=datalr(1:10242);
asub = subaxis(4,2,1, 'sh', 0, 'sv', 0, 'padding', 0, 'margin', 0);
%asub = subplot(4,2,1)
% note use of subaxis is to ged rid of white space around brains 
% if you don't care about that, it's faster and less likely to cause
% issues if you use subplot instead
% if so, bet rid of all of the posnew stuff below

aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
axis vis3d off;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)

asub = subaxis(4,2,3, 'sh', 0.00, 'sv', 0.00, 'padding', 0, 'margin', 0);
aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
rotate(aplot, [0 0 1], 180)
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
axis vis3d off;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
set(gcf,'Color','w')

asub = subaxis(4,2,5, 'sh', 0.0, 'sv', 0.0, 'padding', 0, 'margin', 0);
aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
rotate(aplot, [0 0 1], 225)
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
axis vis3d off;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
set(gcf,'Color','w')

asub = subaxis(4,2,7, 'sh', 0.0, 'sv', 0.0, 'padding', 0, 'margin', 0, 'MT', 0.0);
aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
axis vis3d off;
rotate(aplot, [0 1 0], 270)
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
set(gcf,'Color','w')

 pos = get(asub, 'Position');
 posnew = pos; posnew(2) = posnew(2) + 0.04; set(asub, 'Position', posnew);
 %white space again

%plot title 
title(plot_text)
set(get(gca,'title'),'Position',[332 119 3])

%%% right hemisphere
data=datalr(10243:20484);

[vertices, faces] = freesurfer_read_surf('/project/imco/surfaces/fsaverage5/surf/rh.inflated');

asub = subaxis(4,2,2, 'sh', 0.0, 'sv', 0.0, 'padding', 0, 'margin', 0);
aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
rotate(aplot, [0 0 1], 180)
colormap(custommap)
caxis([mincol; maxcol]);
%caxis([NAval; max_data])
daspect([1 1 1]);
axis tight;
axis vis3d off;
lighting phong; %gouraud
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
%colormap(mycol)


 pos = get(asub, 'Position');
 posnew = pos; posnew(1) = posnew(1) - 0.22; set(asub, 'Position', posnew);

asub = subaxis(4,2,4, 'sh', 0.0, 'sv', 0.0, 'padding', 0, 'margin', 0);
aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
axis vis3d off;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
set(gcf,'Color','w')
 pos = get(asub, 'Position');
 posnew = pos; posnew(1) = posnew(1) - 0.22; set(asub, 'Position', posnew);

asub = subaxis(4,2,6, 'sh', 0.0, 'sv', 0.0, 'padding', 0, 'margin', 0);

aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
rotate(aplot, [0 0 1], -45)
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
axis vis3d off;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
set(gcf,'Color','w')
 pos = get(asub, 'Position');
 posnew = pos; posnew(1) = posnew(1) - 0.22; set(asub, 'Position', posnew);


%%%
asub = subaxis(4,2,8, 'sh', 0.0, 'sv', 0.0, 'padding', 0, 'margin', 0);

aplot = trisurf(faces, vertices(:,1), vertices(:,2), vertices(:,3),data)
view([90 0]);
axis vis3d off;
rotate(aplot, [0 1 0], 270)
rotate(aplot, [1 0 0], 180)
colormap(custommap)
caxis([mincol; maxcol]);
daspect([1 1 1]);
axis tight;
lighting gouraud; %phong; 
material metal %shiny %metal; 
shading flat;
camlight;
alpha(1)
%set(gcf,'Color',[.2 .2 .2])
set(gcf,'Color',[1,1,1])
 pos = get(asub, 'Position');
 posnew = pos; posnew(2) = posnew(2) + 0.04; set(asub, 'Position', posnew);
 pos = get(asub, 'Position');
 posnew = pos; posnew(1) = posnew(1) - 0.22; set(asub, 'Position', posnew);
%%%


acbar = colorbar('EastOutside')
set(acbar, 'position', [0.40 0.270 0.02 0.20])


% going lower rez for now, but giant vector rendering was beaut
print('-dpng','-r600',['/project/imco/baller/results/images/pbp/' char(name)])
```



#### Spin Test 

In reviewing our results, it looked very clear that the sex and executive accuracy maps followed very closely onto Yeo 7 networks. For interpretability and for graphs, we decided to do a variation on the spin test. Overall, the goal was to take the vertices (10242 for each hemisphere), and spin. We would next ask how many vertices would randomly and by chance fall within certain yeo networks as compared to what we actually saw. A challenge of this spin is that when we spin the vertices, we include medial wall which is guaranteed to be 0. In order to account for this, we calculated the proportion of vertices within each network minus the ones in the medial wall. We then used ggplot2 to make violin plots for display.

Unfortunatley, this was another step where we required both matlab and R. Lucky for you, I have a bash wrapper that calls matlab!

First, I made trinarized yeo masks, 1, 0, -1. In order to run permutation analyses on the Yeo networks, I need to trinarize my fdr corrected maps. If a vertex is corrected, it will get a 1. If not, 0. If it is within the medial wall, it will get a -1

script: /project/imco/baller/scripts/spin_test/make_trinarized_maps_for_spin_test.R
```{r make_trinarized_maps_for_spin_test, eval=FALSE}
###########################################
### Make Trinarzied Maps for Spin Test  ###
###########################################

### Author: Erica Baller
### Date 3/10/21

### pre: statistical maps (l and r), each 10242 vertices
### post: 6 matrices with 1s if value fdr corrected, 0 if not, and -1 if vertex in medial wall of yeo map
    # lh and rh pos and neg together, positive alone, and negative alone
### uses: In order to spin my vertices in a way that allows me to later assess their yeo membership, I need all of my fdr values indicated, as well as which values are in the medial wall.  This script takes lh and rh fdr corrected vectors generated in previous scripts, booleanizes them into in/out of fdr map. Then, -1s are added for vertices in the medial wall. 
### dependencis: and R will do. I used 3.2.5

## set abs and relative paths. Must toggle before running locally/on cluster
#homedir = "/Users/eballer/BBL/imco/pmacs/PMACS_remote"
#homedir = "/project/imco"

#### set # parcels in case I want to do 7 or 17 or something else in the future
parcel_type = "Yeo" 
parcel_num = 7 
input_parcel_array_length = 10242

#will loop through each of these
analyses <- c("coupling_accuracy") #, "cbf_accuracy", "alff_accuracy") 
models <- c("gam_age", "gam_sex", "lm_sex", "lm_exec_accuracy", "gam_exec_accuracy") #gam_age", "lm_age", "gam_sex", "lm_sex", "lm_accuracy", "lm_exec_accuracy")
corrs <- c("fdr05") #correction

parcel_mapping <- get_parcel_mapping_yeo(7)
lh_numerical_map <- parcel_mapping[[1]]
rh_numerical_map <- parcel_mapping[[2]]

for (analysis in analyses) {
  for (model in models) {
    for (corr in corrs) {  
      
      ### set results path
      stat_path <- paste0("/", analysis, "/")
      print(stat_path)
      result_path <- paste0(model, "_t_", corr)
      print(result_path)
      
      ### set paths
      ## input
      lh_stat_map <- read.csv(paste0(homedir, "/baller/results/", stat_path, "lh_", result_path, ".csv"), header = F)
      rh_stat_map <- read.csv(paste0(homedir, "/baller/results/", stat_path, "rh_", result_path, ".csv"), header = F)
      
      ## output
      lh_outdir <- paste0(homedir, "/baller/results/", stat_path, "lh_", result_path, "_", parcel_type, parcel_num, "_1_0_-1.csv")
      rh_outdir <- paste0(homedir, "/baller/results/", stat_path, "rh_", result_path, "_", parcel_type, parcel_num, "_1_0_-1.csv")
      
      lh_outdir_pos <- paste0(homedir, "/baller/results/", stat_path, "lh_pos_", result_path, "_", parcel_type, parcel_num, "_1_0_-1.csv")
      rh_outdir_pos <- paste0(homedir, "/baller/results/", stat_path, "rh_pos_", result_path, "_", parcel_type, parcel_num, "_1_0_-1.csv")
      
      lh_outdir_neg <- paste0(homedir, "/baller/results/", stat_path, "lh_neg_", result_path, "_", parcel_type, parcel_num, "_1_0_-1.csv")
      rh_outdir_neg <- paste0(homedir, "/baller/results/", stat_path, "rh_neg_", result_path, "_", parcel_type, parcel_num, "_1_0_-1.csv")
      
      #convert stat map to boolean
      lh_stat_boolean <- ifelse(lh_stat_map == 0, 0, 1)
      rh_stat_boolean <- ifelse(rh_stat_map == 0, 0, 1)
      
      lh_stat_boolean_pos <- ifelse(lh_stat_map > 0, 1, 0)
      rh_stat_boolean_pos <- ifelse(rh_stat_map > 0, 1, 0)
      
      lh_stat_boolean_neg <- ifelse(lh_stat_map < 0, 1, 0)
      rh_stat_boolean_neg <- ifelse(rh_stat_map < 0, 1, 0)
      
      #convert NAs to 0
      lh_stat_boolean[is.na(lh_stat_boolean)] <- 0
      rh_stat_boolean[is.na(rh_stat_boolean)] <- 0
      
      lh_stat_boolean_pos[is.na(lh_stat_boolean_pos)] <- 0
      rh_stat_boolean_pos[is.na(rh_stat_boolean_pos)] <- 0
      
      lh_stat_boolean_neg[is.na(lh_stat_boolean_neg)] <- 0
      rh_stat_boolean_neg[is.na(rh_stat_boolean_neg)] <- 0
      
      
      #substitute -1 for those locations with medial wall stuff
      lh_medial_wall_nums <- which(lh_numerical_map == 8)
      rh_medial_wall_nums <- which(rh_numerical_map == 8)
      
      lh_stat_boolean[lh_medial_wall_nums] <- -1
      rh_stat_boolean[rh_medial_wall_nums] <- -1
      
      lh_stat_boolean_pos[lh_medial_wall_nums] <- -1
      rh_stat_boolean_pos[rh_medial_wall_nums] <- -1
      
      lh_stat_boolean_neg[lh_medial_wall_nums] <- -1
      rh_stat_boolean_neg[rh_medial_wall_nums] <- -1
      
    
      #write output
      write.table(x = lh_stat_boolean, file = lh_outdir, quote = F, row.names = F, col.names = F)
      write.table(x = rh_stat_boolean, file = rh_outdir, quote = F, row.names = F, col.names = F)
      
      write.table(x = lh_stat_boolean_pos, file = lh_outdir_pos, quote = F, row.names = F, col.names = F)
      write.table(x = rh_stat_boolean_pos, file = rh_outdir_pos, quote = F, row.names = F, col.names = F)
      
      write.table(x = lh_stat_boolean_neg, file = lh_outdir_neg, quote = F, row.names = F, col.names = F)
      write.table(x = rh_stat_boolean_neg, file = rh_outdir_neg, quote = F, row.names = F, col.names = F)
      
    }
  }
}

      
```


** Call matlab wrapper**

```{bash call_spin_test, eval=FALSE}

#runs whatever command is in the commands_for_matlab file. Currently, it is set to: calc_spinTest_EB
sh run_spin_test_from_command_line.sh

```

** Code in matlab wrapper **

/project/imco/baller/scripts/spin_test/run_spin_test_from_command_line.sh

```{bash run_spin_test_from_command_line, eval=FALSE}
#!/bin/sh

##################################
###    Spin Test    Wrapper    ###
##################################

###### Author: Erica Baller ######
######   Date: 2/26/2021    ######

## pre: commands_for_matlab 
   #- trinarized maps 
## post: spin results in /project/imco/baller/results/coupling_accuracy/spin_test_results
## uses: I was getting tired of having to open matlab and run each of these commands manually. This script takes a bunch of commands and just feeds them to matlab, no muss, no fuss
## dependencies: Matlab 2020b, please run "source /project/imco/baller/scripts/load_matlab before starting this


#set directories
#homedir = '/project/imco'
#set homedir = '/Users/eballer/BBL/imco/pmacs/PMACS_remote/'
wking_dir='/baller/scripts/spin_test'
command_file="$homedir/$wking_dir/commands_for_matlab"
echo $command_file

#initialize matlab


#######
### loop ###
while IFS= read -r line; do
	echo "$line"
	matlab -nosplash -nodesktop -nodisplay -r "$line; exit"

done < $command_file

```

** commands for matlab **
 file: /project/imco/baller/scripts/spin_test/commands_for_matlab

```{bash commands_for_matlab_spin, eval=FALSE}
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_gam_sex_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_sex_t_fdr05_Yeo7_1_0_-1.csv',1000,'/p
roject/imco/baller/results/coupling_accuracy/spin_test_results/gam_sex_spin_results_yeo_1_0_-1_output','gam_sex')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_lm_exec_accuracy_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_exec_accuracy_t_fdr05_Yeo7_1_
0_-1.csv',1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/lm_exec_accuracy_spin_results_yeo_1_0_-1_output','lm_exec_accuracy')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_pos_gam_sex_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_gam_sex_t_fdr05_Yeo7_1_0_-1.csv',
1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/pos_gam_sex_spin_results_yeo_1_0_-1_output','pos_gam_sex')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_neg_gam_sex_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_gam_sex_t_fdr05_Yeo7_1_0_-1.csv',
1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/neg_gam_sex_spin_results_yeo_1_0_-1_output','neg_gam_sex')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_pos_lm_exec_accuracy_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_exec_accuracy_t_fdr05
_Yeo7_1_0_-1.csv',1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/pos_lm_exec_accuracy_spin_results_yeo_1_0_-1_output','pos_lm_exec_accuracy')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_neg_lm_exec_accuracy_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_exec_accuracy_t_fdr05
_Yeo7_1_0_-1.csv',1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/neg_lm_exec_accuracy_spin_results_yeo_1_0_-1_output','neg_lm_exec_accuracy')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_gam_exec_accuracy_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_exec_accuracy_t_fdr05_Yeo7_1
_0_-1.csv',1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/gam_exec_accuracy_spin_results_yeo_1_0_-1_output','gam_exec_accuracy')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_pos_gam_exec_accuracy_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_gam_exec_accuracy_t_fdr0
5_Yeo7_1_0_-1.csv',1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/pos_gam_exec_accuracy_spin_results_yeo_1_0_-1_output','pos_gam_exec_accuracy')
SpinPermuFS('/project/imco/baller/results/coupling_accuracy/lh_neg_gam_exec_accuracy_t_fdr05_Yeo7_1_0_-1.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_gam_exec_accuracy_t_fdr0
5_Yeo7_1_0_-1.csv',1000,'/project/imco/baller/results/coupling_accuracy/spin_test_results/neg_gam_exec_accuracy_spin_results_yeo_1_0_-1_output','neg_gam_exec_accuracy')
```

The contents of SpinPermuFS (of note, I added an extra variable, model, so I could change what is actually called)

```{bash SpunPermuFS, eval=FALSE}
function SpinPermuFS(readleft,readright,permno,wsname,model)
% Compute designated # of permutations/spins of the input surface data
% in FreeSurfer fsaverage5.
% FORMAT SpinPermuFS(readleft,readright,permno)
% readleft     - the filename of left surface data to spin 
% readright    - the filename of right surface data to spin 
% permno       - the number of permutations
% wsname       - the name of a workspace file including all spun data to be saved
% model        - gam_accuracy, lm_accuracy, gam_sex, etc
% Example   SpinPermuFS('../data/depressionFSdataL.csv','../data/depressionFSdataR.csv',100,'../data/rotationFS.mat')
% will spin prebuilt data, neurosynth map associated with 'depression', 100
% times, and save the workspace file of all spun data in ../data/rotationFS.mat
% Aaron Alexander-Bloch & Siyuan Liu 
% SpinPermuFS.m, 2018-04-22
% The implementation of generating random rotations originally described in our paper — 
% rotating the coordinates of vertices at angles uniformly chosen between zero and 360 degrees
% about each of the x (left-right), y (anterior-posterior) and z (superior-inferior) axes —
% introduces a preference towards oversampling certain rotations. 
% Thus, we modified the code to incorporate an approach, Lefèvre et al. (2018), 
% that samples uniformly from the space of possible rotations. The updated
% uniform sampling prodcedure does not require AxelRot.m anymore.
% Updated on 2018-07-18


%outdir= '/project/imco/baller/results/coupling_accuracy/spin_test_results/';

%Set up paths
fshome = getenv('FREESURFER_HOME');
fsmatlab = sprintf('%s/matlab',fshome);
path(path,fsmatlab);
%read the data saved in csv
datal=importdata(readleft);
datar=importdata(readright);


%%extract the correspoding sphere surface coordinates for rotation
% AP changed the filepath 10/26/20, i don't know how cubic managed to set up a fshome path not amenable to this
[verticesl, ~] = freesurfer_read_surf(fullfile('/project/imco/surfaces/fsaverage5/surf/lh.sphere'));
[verticesr, ~] = freesurfer_read_surf(fullfile('/project/imco/surfaces/fsaverage5/surf/rh.sphere'));


rng(0);
%Use rng to initialize the random generator for reproducible results.
%initialize variables to save rotation
bigrotl=[];
bigrotr=[];
distfun = @(a,b) sqrt(bsxfun(@minus,bsxfun(@plus,sum(a.^2,2),sum(b.^2,1)),2*(a*b)));
%function to calculate Euclidian distance
I1 = eye(3,3);
I1(1,1)=-1;
bl=verticesl;
br=verticesr;
%permutation starts
for j=1:permno
    j
    %the updated uniform sampling procedure
    A = normrnd(0,1,3,3);
    [TL, temp] = qr(A);
    TL = TL * diag(sign(diag(temp)));
    if(det(TL)<0)
        TL(:,1) = -TL(:,1);
    end
    %reflect across the Y-Z plane for right hemisphere
    TR = I1 * TL * I1;
    bl =bl*TL;
    br = br*TR;    
    
    %Find the pair of matched vertices with the min distance and reassign
    %values to the rotated surface.
    distl=distfun(verticesl,bl');
    distr=distfun(verticesr,br');
    [~, Il]=min(distl,[],2);
    [~, Ir]=min(distr,[],2);
    %save rotated data
    bigrotl=[bigrotl; datal(Il)'];
    bigrotr=[bigrotr; datar(Ir)'];
    % it is also feasible to save Il Ir and apply them to different datasets
    % for repeated use
    %If annotation file is used, annotation file for each rotation could be
    %saved by write_annotation.m of FreeSurfer
end
save(wsname,'bigrotl','bigrotr')
writematrix(bigrotl, [outdir, '/lh_spintest_', model, '_output.csv']);
writematrix(bigrotr, [outdir, '/rh_spintest_', model, '_output.csv']);
%save bigrotl and bigrotr in a workspace file for the null distribution
%use it in pvalvsNull.m to caclulate pvalue

```

** Here we actually generate the proportion matrices and plot **

```{r spin_proportion_calculations_and_plots, eval=FALSE}
##############################################
########### Spin Test Distribution for #######
##########Intermodal Coupling Paper ##########

####### Author: Erica Baller
#### Date: 3/9/2021

#######
##pre: right and left 10242 x 1000 matrices from matlab SpinPermuFS, yeo R & L assignments
##post: 2 7 x 1000 matrices (r & l) that contain the proportion of vertices within a network divided by the total number of vertices, and plots
## uses: Takes output of spin test, and calcualted the number of vertices within each of yeo's 7 networks out of the number of total possible vertices within the network
    #### 1) Read in the yeo network assignments and calculate total number of vertices per network
    #### 2) Multiply the yeo networks x the matrices (so every value is 1 -7 if they were within the mask, -1--7 if they were medial wall, and 0 otherwise)
    #### 3) Foreach permutation (r and l separately), and for each network, calculate the (# of vertices with a 1) divided(/) by the (number of total vertices within network minus number of negative vertices
    #### 4) Store
    #### 5) Plot

### dependencies: ggplot2, bigmemory, vroom


#library(bigmemory.sri)
library(ggplot2)
library(tidyr)



#################
### set home directory
#homedir <- "/Users/eballer/BBL/imco/pmacs/PMACS_remote"
homedir <- "/project/imco"

source(paste0(homedir, "/baller/scripts/imco_functions.R"))

#initialize
hemis <- c("lh", "rh")
permNum <- 1000
yeo_num <- 7
models = c("gam_sex", "pos_gam_sex", "neg_gam_sex", "lm_exec_accuracy", "pos_lm_exec_accuracy", "neg_lm_exec_accuracy", "gam_exec_accuracy", "pos_gam_exec_accuracy", "neg_gam_exec_accuracy")
#models = c("lm_exec_accuracy", "pos_lm_exec_accuracy", "neg_lm_exec_accuracy")
################
### Read in matrices 
for (model in models) {
  #{lh and rh}_gam_sex_t_fdr05 -> actual results
  lh_t_fdr05_results <- read.table(paste0(homedir, "/baller/results/coupling_accuracy/lh_", model, "_t_fdr05_Yeo7_1_0_-1.csv"))
  rh_t_fdr05_results <- read.table(paste0(homedir, "/baller/results/coupling_accuracy/rh_", model, "_t_fdr05_Yeo7_1_0_-1.csv"))
  
  #spins
  lh_spin <- t(read.table(paste0(homedir, "/baller/results/coupling_accuracy/spin_test_results/lh_spin_test_", model,"_output.csv"), sep = ","))
  rh_spin <- t(read.table(paste0(homedir, "/baller/results/coupling_accuracy/spin_test_results/rh_spin_test_", model,"_output.csv"), sep = ","))
                                          
  #bring together, with original values as first column
  lh_act_results_and_spin <- cbind(lh_t_fdr05_results, lh_spin)
  rh_act_results_and_spin <- cbind(rh_t_fdr05_results, rh_spin)
  
  #grab list of yeo 7 networks in fsaverage5 space
  yeo_networks <- get_parcel_mapping_yeo(yeo_num)
  
  #separate into right and left
  lh_yeo_network <- yeo_networks[[1]]
  rh_yeo_network <- yeo_networks[[2]]
  
  #count up number of vertices per network
  lh_yeo_network_count_table <- table(lh_yeo_network)
  rh_yeo_network_count_table <- table(rh_yeo_network)
  
  #multiply yeo network x spin test
  lh_spinxyeo <- lh_act_results_and_spin*lh_yeo_network
  rh_spinxyeo <- rh_act_results_and_spin*rh_yeo_network
  
  #proportions
  #go through each hemisphere, go through each perm, and go through each network
  
  lh_hemi_spin_proportions <- data.frame(matrix(nrow = yeo_num, ncol = (permNum + 1)))
  rh_hemi_spin_proportions <- data.frame(matrix(nrow = yeo_num, ncol = (permNum + 1)))
  for (hemi in hemis){

    for (perm in 1:(permNum + 1)){
      
      for (network in 1:yeo_num){
        
        #to evaluate
        
        #number of vertices within network that are fdr corrected
        num_pos_to_parse<- paste0("length(which(", hemi, "_spinxyeo[", perm, "] == ", network, "))")
        
        num_vertices_in_spin <- eval(parse(text = as.character(num_pos_to_parse)))
        
        
        #number of vertices within network that are negative (i.e., medial wall)
        num_neg_to_parse <- paste0("length(which(", hemi, "_spinxyeo[", perm, "] == -", network, "))")
      
        num_neg <- eval(parse(text = as.character(num_neg_to_parse)))
        
        
        #total number of vertices in normal network
        total_possible_to_parse <- paste0(hemi, "_yeo_network_count_table[", network, "]")
 
        total_possible <- eval(parse(text = as.character(total_possible_to_parse)))
        
       
        #proportion of vertices within network , with denominator being total possible by # in medial wall
        proportion_potential_vertices <- num_vertices_in_spin/(total_possible - num_neg)
    
        
        #store in matrix
        storing_to_parse <- paste0(hemi, "_hemi_spin_proportions[", network, ",", perm, "] = ", proportion_potential_vertices)

        eval(parse(text = as.character(storing_to_parse)))
      }
    }
  }
  
  write.table(lh_hemi_spin_proportions, file = paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_", model, "_proportions.csv"), sep = ",", col.names = F, row.names = F)
  write.table(rh_hemi_spin_proportions, file = paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_", model, "_proportions.csv"), sep = ",", col.names = F, row.names = F)
#then plot
}

```

** violin plotting the spin tests and getting stats **

From /project/imco/baller/scripts/spin_test/violin_plots.R . This provides a platform for analysis and visualization of the permuted results. It calls a few functions from the imco_functions.R script, so you must source it (uncomment that line) in this section if running independtly. Otherwise, it should load if running this document start to finish.
```{r violin_plots, eval=FALSE}
####### Violin Plots ###


#### Author: Erica Baller

### 3/16/2021

###pre: requires that you have run the spin tests for your models, including the positive and negative spin tests
###post: 2 violin plots per model. Violin plot x axis - yeo networks, y axis - proportion of vertices within networks. dotted lines - mean from permutations
   #### plot 1 will contain a thick black line for the *actual values from your analysis so you can compare how far above or below your value is from permuted
   #### plot 2 will contain red lines detailing where the actual values from your analysis from the POSITIVE domain, blue for NEGATIVE
   #### You will also get a table that tells you the p value (uncorrected) for each network within each model.
   #### for my final plot, I added a * to these manually
### uses: Creates violin plots and analyses to help make sense of the results from permutation spin tests. The question we are asking is:
    ### what is the likelihood that the number of vertices within a network is significant rather than due to chance
### dependencies: Using R 3.6.3 but any R will do. Libraries to include listed below

library(tidyr)
library(ggplot2)
library(reshape)

#################
### set home directory
homedir <- "/Users/eballer/BBL/imco/pmacs/PMACS_remote"
#homedir <- "/project/imco"
source(paste0(homedir, '/baller/scripts//imco_functions.R'))

#outdir_name <- "spin_stats_gam_sex_lm_exec_acc_all_pos_neg"
outdir_name <- "spin_stats_gam_sex_gam_exec_acc_all_pos_neg"

models_for_stats = c("gam_age", "pos_gam_age", "neg_gam_age", "gam_sex", "pos_gam_sex", "neg_gam_sex","lm_exec_accuracy", "pos_lm_exec_accuracy", "neg_lm_exec_accuracy", "gam_exec_accuracy", "pos_gam_exec_accuracy", "neg_gam_exec_accuracy", "mean_coupling")
models_for_plots = c("gam_age", "gam_sex", "lm_exec_accuracy", "gam_exec_accuracy")

network_names <- c("VIS", "MOT", "DA", "VA", "LIM", "FP", "DM")
num_spins = 2000
#get Yeo colors from function, these values were set manually - this can be obtained through https://surfer.nmr.mgh.harvard.edu/fswiki/CorticalParcellation_Yeo2011
   #I typed the RGB values into a rgb -> hex converter and stored the values here. Works!

yeo_colors <- get_yeo7_colors()

#for storing statistics at the end
stats <- data.frame(matrix(nrow = 7, ncol = length(models_for_stats)))
names(stats) <- models_for_stats
row.names(stats) <- network_names

for (model in models_for_stats) {
  
  if (model == "mean_coupling") {
    lh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_mean_coupling.csv"), sep = ","))
    rh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_mean_coupling.csv"), sep = ","))
  } else {
    lh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_", model, "_proportions.csv"), sep = ","))
    rh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_", model, "_proportions.csv"), sep = ","))
  }
  
  
  #take means of left and right
  actual_results <- (lh_spin_df[,1] + rh_spin_df[,1])/2
  
  #dataframes for all spins
  spin_without_target_col <- cbind(lh_spin_df[,2:1001],rh_spin_df[,2:1001])
  
  ####### Stats ########
  for (i in 1:7){
    #store p values
    #equivalen to: stats$model[i] <- (length(which(spin_without_target_col[i,] > actual_results[i]))/2000)
    eval(parse(text=as.character(paste0("stats$", model, "[", i ,"] <- (length(which(spin_without_target_col[",i, ",] > actual_results[", i, "]))/", num_spins, ")"))))
  }
}

print(stats)
write.csv(stats, paste0(homedir, "/baller/results/coupling_accuracy/spin_test_results/", outdir_name, ".csv"))

violin_plot_means_mean_coupling(homedir = homedir, network_names = network_names, num_spins = num_spins)
violin_plot_pos_and_neg_lines(homedir = homedir, models = models_for_plots, network_names = network_names, num_spins = num_spins)
violin_plot_means(homedir = homedir, models = models_for_plots, network_names = network_names, num_spins = num_spins)


```

Gam sex violin plots
<img width="100%" src="/project/imco/baller/results/images/spin_gam_sex_pos_and_neg_lines_t_fdr05.png"/>

Lm exec accuracy plots
<img width="100%" src="/project/imco/baller/results/images/spin_lm_exec_accuracy_pos_and_neg_lines_t_fdr05.png"/>

Gam exec accuracy plots
<img width="100%" src="/project/imco/baller/results/images/spin_gam_exec_accuracy_pos_and_neg_lines_t_fdr05.png"/>

#### Checking to see which of the previously defined maps have the most overlap with our coupling  maps

 - There are many masks that are available and we have previously used to understand brain dynamics. Here, I look at the correlation between coupling and glycolytic index map, hill2010_evo map, allometric_scaling map, cerebral metabolic rate of glucose map, and cbf map. It turns out, the cerebral metabolic rate of glucose map is the one with the highest overlap. However, this wasn't as revealing as we had hoped, so we did not pursue this further.
```{r correlations_with_masks}

#########################################
## Correlations of coupling with masks ##
#########################################

### Author: Erica Baller
## Date: 2/26/2021

### This script emerged out of the desire to take vertex output and display it within different networks/parcels

#pre: input: 
#1) mean coupling map, r and l side
#2) masks, GI, Hill, CBF, etc

#post - matrix of correlations for each of the maps

#uses - We want to see which of the masks best correlates with mean coupling. To do this, will correlate the uncorrected mean map with the GI map, Hill2010, and all the others

#dependencies: Any R will do, I used 3.2.5

# set home directory
#homedir = '/Users/eballer/BBL/imco/pmacs/PMACS_remote/'
#homedir = '/project/imco'

#mean coupling maps
mean_coupling_map <- rbind(read.csv(paste0(homedir, "/baller/results/mean_maps/n831_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5.csv"), header = F),
                           read.csv(paste0(homedir, "/baller/results/mean_maps/n831_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5.csv"), header = F))

#gi maps
gi_map <- rbind(read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/lh.GI_fsaverage5_10242.csv"), header = F),
                read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/rh.GI_fsaverage5_10242.csv"), header = F))

#hill2010
hill_map <- rbind(read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/lh.Hill2010_evo_fsaverage5.csv"), header = F),
                  read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/rh.Hill2010_evo_fsaverage5.csv"), header = F))

#allometric scaling
as_map <- rbind(read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/lh.AllometricScaling_fsaverage5.csv"), header = F),
                read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/rh.AllometricScaling_fsaverage5.csv"), header = F))

#cmrglu
cmrglu_map <- rbind(read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/lh.CMRGlu_fsaverage5.csv"), header = F),
                    read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/rh.CMRGlu_fsaverage5.csv"), header = F))

#meancbf
meancbf_map <- rbind(read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/lh.MeanCBF.fsaverage5.csv"), header = F),
                     read.csv(paste0(homedir, "/baller/processed_data/zaixu_maps/fsaverage5/rh.MeanCBF.fsaverage5.csv"), header = F))

maps <- c('mean_coupling_map','gi_map', 'hill_map', 'as_map', 'cmrglu_map', 'meancbf_map')

correlations <- data.frame(matrix(0, nrow = 1, ncol = 6))
names(correlations) <- maps
row.names(correlations) <- "mean_coupling_map"

i = 1
for (map in maps) {
    map_to_corr <- map
    corr_cmd <- paste0("cor(x = mean_coupling_map, ", "y =", map_to_corr, ", method=c(\"pearson\"))")
    corr_results <- eval(parse(text = as.character(corr_cmd)))
    print(paste0("mean_coupling_map:", map_to_corr, "--> R = ", corr_results))
    correlations[1,i] = corr_results
    i <- i + 1

}

### correlations only using nonzero values in mean coupling map
mean_coupling_map_nonzero <- mean_coupling_map$V1
mean_coupling_map_nonzero[mean_coupling_map_nonzero==0] <- NA #set the 0s to NA so we can drop them in the next step

correlations_nonzero <- data.frame(matrix(0, nrow = 2, ncol = 6))
names(correlations_nonzero) <- maps
row.names(correlations_nonzero) <- c("mean_coupling_map_nonzero_cor", "mean_coupling_map_nonzero_lm")

i = 1
for (map in maps) {
    map_to_corr <- map
    

    # do correlations
    corr_cmd <- paste0("cor(x = mean_coupling_map_nonzero, ", "y =", map_to_corr, "$V1, method=c(\"pearson\"), use=\"complete.obs\")")
    corr_results <- eval(parse(text=as.character(corr_cmd)))
  
    lm_cmd <- paste0("round(summary(lm(mean_coupling_map_nonzero ~ ", map_to_corr, "$V1))$coefficients[2,4], 3)")
    lm_results <- eval(parse(text=as.character(lm_cmd)))
    
    ###plots
    plot_cmd <- paste0("plot(mean_coupling_map_nonzero, ", map_to_corr, "$V1, ylab = \"", map_to_corr,"\")")
    eval(parse(text=as.character(plot_cmd)))
    
    print(paste0("mean_coupling_map:", map_to_corr, "--> R = ", corr_results))
    correlations_nonzero[1,i] = corr_results
    correlations_nonzero[2,i] = lm_results
    i <- i + 1

}

print(correlations)

print(correlations_nonzero)

cbf_cmr_cor <- cor.test(meancbf_map$V1, cmrglu_map$V1, method = "pearson")
cbf_gi_cor <- cor.test(meancbf_map$V1, gi_map$V1, method = "pearson")
print(paste0("correlation to verify CBF good measure of metabolism: cbf x cmr -> R =  ", cbf_cmr_cor$estimate, "; p = ", cbf_cmr_cor$p.value))
print(paste0("correlation to verify CBF good measure of metabolism: cbf x gi -> R =  ", cbf_gi_cor$estimate, "; p = ", cbf_gi_cor$p.value))


####### write output
write.csv(correlations, file = paste0(homedir, "/baller/results/mean_coupling_x_mask_correlations/mean_coupling_map_x_mask_correlations.csv"), quote = F)

write.csv(correlations_nonzero, file = paste0(homedir, "/baller/results/mean_coupling_x_mask_correlations/mean_coupling_map_non_zeros_x_mask_correlations.csv"), quote = F)
```

Lastly, finding a way to match vertices with MNI coordinates
```{r coordinates_to_mni}

#### takes trinarized masks, matches them to MNI coordinates from fsGLM script on chead, and takes out uncorrected data
#### This allows for manually mapping the significant vertices to brain

lh_coordinates <- read.table(paste0(homedir, "/baller/processed_data/map_of_mni_coordinates/lh_coordinates.csv"), header = F)
rh_coordinates <- read.table(paste0(homedir, "/baller/processed_data/map_of_mni_coordinates/rh_coordinates.csv"), header = F)


#initialize
models = c("gam_age", "gam_sex", "gam_exec_accuracy")


################
### Read in matrices 
for (model in models) {
  #{lh and rh}_gam_sex_t_fdr05 -> actual results
  lh_t_fdr05_results <- read.table(paste0(homedir, "/baller/results/coupling_accuracy/lh_", model, "_t_fdr05_Yeo7_1_0_-1.csv"))
  rh_t_fdr05_results <- read.table(paste0(homedir, "/baller/results/coupling_accuracy/rh_", model, "_t_fdr05_Yeo7_1_0_-1.csv"))
  
  lh_results_with_coors <- cbind(lh_coordinates, lh_t_fdr05_results)
  lh_results_with_coors <- lh_results_with_coors[which(lh_results_with_coors$V5 == 1),]
  write.table(x=lh_results_with_coors, file = paste0(homedir, "/baller/results/coupling_accuracy/lh_", model, "_t_fdr05_mni_coordinates.csv"))
  
  rh_results_with_coors <- cbind(rh_coordinates, rh_t_fdr05_results)
  rh_results_with_coors <- rh_results_with_coors[which(rh_results_with_coors$V5 == 1),]
  write.table(x = rh_results_with_coors, file = paste0(homedir, "/baller/results/coupling_accuracy/rh_", model, "_t_fdr05_mni_coordinates.csv"))
  
}

```

For tomorrow: https://surfer.nmr.mgh.harvard.edu/fswiki/FsTutorial/AnatomicalROI#Relationshipbetweensegmentation.2CparcellationandLookUpTable.28LUT.29


New images made on PMACS:/project/imco/baller/scripts/PBP_graphics

First, get these pics locally if you want an easier time visualizing. Right now, paths are set up to run off pmacs

scp eballer@transfer.pmacs.upenn.edu:/project/imco/baller/results/images/pbp/* /Users/eballer/BBL/imco/results/images/pbp/.



-----

** Yeo7 (PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath.m) **

-----

Using the following mapping of Yeo network to random coded number to num for display

<img width="100%" src="/project/imco/baller/results/images/Yeo7_net_to_number.png"/>


[x] coupling gam age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_gam_age_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_age_t_fdr05_Yeo7.csv','coupling_gam_age_yeo7_fdr05')

[x] coupling lm age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_lm_age_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_age_t_fdr05_Yeo7.csv','coupling_lm_age_yeo7_fdr05')  

[x] coupling lm sex, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_lm_sex_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_sex_t_fdr05_Yeo7.csv','coupling_lm_sex_yeo7_fdr05')  

[x] coupling lm exec accuracy, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_lm_exec_accuracy_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_exec_accuracy_t_fdr05_Yeo7.csv','coupling_lm_exec_accuracy_yeo7_fdr05')   

<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_gam_age_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_age_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_sex_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_exec_accuracy_yeo7_fdr05.png"/>


----- 
** Positive Direction **
-----

[x] coupling lm age, T=pos, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_pos_lm_age_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_age_t_fdr05_Yeo7.csv','coupling_pos_lm_age_yeo7_fdr05')  

[x] coupling lm sex, T=pos, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_pos_lm_sex_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_sex_t_fdr05_Yeo7.csv','coupling_pos_lm_sex_yeo7_fdr05') 

[x] coupling lm exec accuracy, T=pos, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_pos_lm_exec_accuracy_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_exec_accuracy_t_fdr05_Yeo7.csv','coupling_pos_lm_exec_accuracy_yeo7_fdr05')


<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_pos_lm_age_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_pos_lm_sex_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_pos_lm_exec_accuracy_yeo7_fdr05.png"/>

----- 
** Negative Direction **
-----

[x] coupling lm age, T=neg, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_neg_lm_age_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_age_t_fdr05_Yeo7.csv','coupling_neg_lm_age_yeo7_fdr05') 

[x] coupling lm sex, T=neg, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_neg_lm_sex_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_sex_t_fdr05_Yeo7.csv','coupling_neg_lm_sex_yeo7_fdr05')

[x] coupling lm exec accuracy, T=neg, fdr05

command: PBP_vertWiseEffect_Erica_Ts_Yeo7_colors_results_outpath('//project/imco/baller/results/coupling_accuracy/lh_neg_lm_exec_accuracy_t_fdr05_Yeo7.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_exec_accuracy_t_fdr05_Yeo7.csv','coupling_neg_lm_exec_accuracy_yeo7_fdr05')


<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_neg_lm_age_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_neg_lm_sex_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_neg_lm_exec_accuracy_yeo7_fdr05.png"/>

-----
** Mean images (PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath.m) **
-----

[x] mean coupling (abs(T)>2)

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('//project/imco/baller/results/mean_maps/n831_lh.coupling_coef_alff_cbf.fwhm15.fsaverage5.csv','/project/imco/baller/results/mean_maps/n831_rh.coupling_coef_alff_cbf.fwhm15.fsaverage5.csv','coupling_mean_fdr05')

[x] mean alff (abs(T)>2)

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('//project/imco/baller/results/mean_maps/lh_alff_mean.csv','/project/imco/baller/results/mean_maps/rh_alff_mean.csv','alff_mean_fdr05')

[x] mean cbf (abs(T)>2)

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('//project/imco/baller/results/mean_maps/lh_cbf_mean.csv','/project/imco/baller/results/mean_maps/rh_cbf_mean.csv','cbf_mean_fdr05')

mean image (PBP_vertWiseEffect_Erica_GI.m)
[x] aerobic glycolysis

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/processed_data/glycolytic_index_maps/lh_GI_fsaverage5_10242.csv','/project/imco/baller/processed_data/glycolytic_index_maps/rh_GI_fsaverage5_10242.csv','glycolytic_index_red_blue')

<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_mean_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/alff_mean_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/cbf_mean_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_red_blue.png"/>

-----
** Blue and red coupling maps (PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath.m) **
-----

[x] coupling gam age

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_age_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_age_t_fdr05.csv','coupling_gam_age_red_and_blue_fdr05')

[x] coupling lm age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_age_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_age_t_fdr05.csv','coupling_lm_age_red_and_blue_fdr05')


[x] coupling lm sex, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_sex_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_sex_t_fdr05.csv','coupling_lm_sex_red_and_blue_fdr05')

[x] coupling lm exec accuracy, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_exec_accuracy_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_exec_accuracy_t_fdr05.csv','coupling_lm_exec_accuracy_red_and_blue_fdr05')

<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_gam_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_sex_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_exec_accuracy_red_and_blue_fdr05.png"/>

-----
** Alff maps **
-----

[x] alff gam age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/alff_accuracy/lh_gam_age_t_fdr05.csv','/project/imco/baller/results/alff_accuracy/rh_gam_age_t_fdr05.csv','alff_gam_age_red_and_blue_fdr05')

[x] alff lm age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/alff_accuracy/lh_lm_age_t_fdr05.csv','/project/imco/baller/results/alff_accuracy/rh_lm_age_t_fdr05.csv','alff_lm_age_red_and_blue_fdr05')

[x] alff lm sex, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/alff_accuracy/lh_lm_sex_t_fdr05.csv','/project/imco/baller/results/alff_accuracy/rh_lm_sex_t_fdr05.csv','alff_lm_sex_red_and_blue_fdr05')

[x] alff lm exec accuracy, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/alff_accuracy/lh_lm_exec_accuracy_t_fdr05.csv','/project/imco/baller/results/alff_accuracy/rh_lm_exec_accuracy_t_fdr05.csv','alff_lm_exec_accuracy_red_and_blue_fdr05')

<img width="40%" src="/project/imco/baller/results/images/pbp/alff_gam_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/alff_lm_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/alff_lm_sex_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/alff_lm_exec_accuracy_red_and_blue_fdr05.png"/>


-----
** Cbf maps **
-----

[x] cbf gam age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/cbf_accuracy/lh_gam_age_t_fdr05.csv','/project/imco/baller/results/cbf_accuracy/rh_gam_age_t_fdr05.csv','cbf_gam_age_red_and_blue_fdr05')

[x] cbf lm age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/cbf_accuracy/lh_lm_age_t_fdr05.csv','/project/imco/baller/results/cbf_accuracy/rh_lm_age_t_fdr05.csv','cbf_lm_age_red_and_blue_fdr05')


[x] cbf lm sex, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/cbf_accuracy/lh_lm_sex_t_fdr05.csv','/project/imco/baller/results/cbf_accuracy/rh_lm_sex_t_fdr05.csv','cbf_lm_sex_red_and_blue_fdr05')

[x] cbf lm exec accuracy, fdr05

command: PBP_vertWiseEffect_Erica_Ts_pos_and_neg_results_outpath('/project/imco/baller/results/cbf_accuracy/lh_lm_exec_accuracy_t_fdr05.csv','/project/imco/baller/results/cbf_accuracy/rh_lm_exec_accuracy_t_fdr05.csv','cbf_lm_exec_accuracy_red_and_blue_fdr05')

<img width="40%" src="/project/imco/baller/results/images/pbp/cbf_gam_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/cbf_lm_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/cbf_lm_sex_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/cbf_lm_exec_accuracy_red_and_blue_fdr05.png"/>

-----
** Gam using the nice plasma (PBP_vertWiseEffect_Erica_Ts_results_outpath.m) **
-----

[x] coupling gam age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_age_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_age_t_fdr05.csv','coupling_gam_age_plasma_fdr05')

[x] alff lm age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_results_outpath('/project/imco/baller/results/alff_accuracy/lh_gam_age_t_fdr05.csv','/project/imco/baller/results/alff_accuracy/rh_gam_age_t_fdr05.csv','alff_gam_age_plasma_fdr05')

[x] cbf gam age, fdr05

command: PBP_vertWiseEffect_Erica_Ts_results_outpath('/project/imco/baller/results/cbf_accuracy/lh_gam_age_t_fdr05.csv','/project/imco/baller/results/cbf_accuracy/rh_gam_age_t_fdr05.csv','cbf_gam_age_plasma_fdr05')

[x] coupling gam exec accuracy, fdr05

command: PBP_vertWiseEffect_Erica_Ts_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_exec_accuracy_t_fdr05.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_exec_accuracy_t_fdr05.csv','coupling_gam_exec_accuracy_plasma_fdr05')

<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_gam_age_plasma_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/alff_gam_age_plasma_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/cbf_gam_age_plasma_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_gam_exec_accuracy_plasma_fdr05.png"/>

-----
** Glycolytic index plasma (PBP_vertWiseEffect_Erica_GI_plasma_results_outpath.m) **
-----

[x] GI

command: PBP_vertWiseEffect_Erica_GI_plasma_results_outpath('/project/imco/baller/processed_data/glycolytic_index_maps/lh_GI_fsaverage5_10242.csv','/project/imco/baller/processed_data/glycolytic_index_maps/rh_GI_fsaverage5_10242.csv','glycolytic_index_plasma')

<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_plasma.png"/>

-----
** Glycolytic index red and blue, masking the T maps (PBP_vertWiseEffect_Erica_GI_results_outpath.m) **
-----

-----
** bidirectional **
-----

[x] gam age, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_gam_age_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_gam_age_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_gam_age')

[x] lm age, pfdr05

command:PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_age_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_age_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_lm_age')

[x] lm sex, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_sex_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_sex_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_lm_sex')

[] lm exec accuracy, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_lm_exec_accuracy_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_lm_exec_accuracy_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_lm_exec_accuracy')

<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_gam_age.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_lm_age.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_lm_sex.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_lm_exec_accuracy.png"/>

-----
** positive direction **
-----

[x] gam age, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_pos_gam_age_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_gam_age_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_pos_gam_age')

[x] lm age, pfdr05

command:PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_pos_lm_age_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_age_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_pos_lm_age')

[x] lm sex, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_pos_lm_sex_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_sex_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_pos_lm_sex')

[x] lm exec accuracy, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_pos_lm_exec_accuracy_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_pos_lm_exec_accuracy_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_pos_lm_exec_accuracy')

<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_pos_gam_age.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_pos_lm_age.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_pos_lm_sex.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_pos_lm_exec_accuracy.png"/>

-----
** negative direction **
-----


[x] gam age, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_neg_gam_age_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_gam_age_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_neg_gam_age')

[x] lm age, pfdr05

command:PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_neg_lm_age_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_age_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_neg_lm_age')

[x] lm sex, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_neg_lm_sex_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_sex_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_neg_lm_sex')

[x] lm exec accuracy, pfdr05

command: PBP_vertWiseEffect_Erica_GI_results_outpath('/project/imco/baller/results/coupling_accuracy/lh_neg_lm_exec_accuracy_t_fdr05_GI_fsaverage5_10242.csv','/project/imco/baller/results/coupling_accuracy/rh_neg_lm_exec_accuracy_t_fdr05_GI_fsaverage5_10242.csv','glycolytic_index_neg_lm_exec_accuracy')

<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_neg_gam_age.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_neg_lm_age.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_neg_lm_sex.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/glycolytic_index_neg_lm_exec_accuracy.png"/>



#### Paper figures

There are a selection of pictures that we will likely use for the paper. I am including them here. 

#### Demographics
<img width="30%" src="/project/imco/baller/results/images/Demographics_from_original_ms.png"/>

#### Yeo info

<img width="100%" src="/project/imco/baller/results/images/Yeo7_net_to_number.png"/>

#### Mean Coupling, Alff, CBF

<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_mean_fdr05.png"/>
<img width="30%" src="/project/imco/baller/results/images/pbp/alff_mean_fdr05.png"/>
<img width="30%" src="/project/imco/baller/results/images/pbp/cbf_mean_fdr05.png"/>

#### Coupling Age

**gam age plasma/ lm red/blue, yeo +, yeo -**

<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_gam_age_plasma_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_lm_age_red_and_blue_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_pos_lm_age_yeo7_fdr05.png"/>
<img width="40%" src="/project/imco/baller/results/images/pbp/coupling_neg_lm_age_yeo7_fdr05.png"/>


#### Coupling Sex

**lm red/blue, yeo +, yeo -**

<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_lm_sex_red_and_blue_fdr05.png"/>
<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_pos_lm_sex_yeo7_fdr05.png"/>
<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_neg_lm_sex_yeo7_fdr05.png"/>

#### Coupling Exec Accuracy

**lm red/blue, yeo +, yeo -**

<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_lm_exec_accuracy_red_and_blue_fdr05.png"/>
<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_pos_lm_exec_accuracy_yeo7_fdr05.png"/>
<img width="30%" src="/project/imco/baller/results/images/pbp/coupling_neg_lm_exec_accuracy_yeo7_fdr05.png"/>



** imco_functions.R **
Lastly, here is the content for the imco functions script. Enjoy!
```{r imco_functions.R, eval=FALSE}
require('visreg')
require('mgcv')
require('tableone')
require('dplyr')

make_demographics_table<- function(data_frame) {
  
  #subset demographics
  listVars <- c("Age", "Sex", "Race", "Maternal Ed") #Race 1 = caucasian, Maternal Ed = years, age = years
  demo <- data.frame(data_frame$ageAtScan1, data_frame$sex, data_frame$race2, data_frame$medu1)
  names(demo) <- c(listVars)
  
  #Change categorical values to have names
  demo$Race <- ifelse(demo$Race == 1, "Caucasian", "Non-caucasian")
  demo$Sex <- ifelse(demo$Sex == 1, "Male", "Female")
 
  #Define Categorical Variables
  cat_variables <- c("Sex", "Race")
  title <- paste0("IMCO Demographics, n = ", dim(demo)[1])
  
  #create demographics table
  demo_table <- CreateTableOne(vars = listVars, data = demo, factorVars = cat_variables)
  print(demo_table, showAllLevels = TRUE)
}

get_parcel_mapping_yeo <- function(parcel_num){
  
  #pre: input parcel #, either 7 or 17
  #post: list lh and rh yeo networks that map onto code #s
  #uses: easy way to translate the weird numerical maps in fsaverage 5 space into something we are more familiar with
  #dependencies: Any R will do, I used 3.2.5
  
  ## Set Yeo info
  #### set # parcels in case I want to do 7 or 17 or something else in the future
  parcel_type = "Yeo" 
  parcel_num = parcel_num 
  input_parcel_array_length = 10242
  
  # read in yeo fsaverage5 vectors
  parcelID <- read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/NetworkIDnumbers", parcel_type, parcel_num, ".csv"), header = F)
  parcelName <- t(read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/NetworkNames", parcel_type, parcel_num, ".csv"), header = F))
  
  lh_parcel_nums <- read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/lh_", input_parcel_array_length, "_vertex_nums_", parcel_type, parcel_num, ".csv"), header = F)
  rh_parcel_nums <- read.csv(paste0(homedir, "/baller/processed_data/yeo_network_data/rh_", input_parcel_array_length, "_vertex_nums_", parcel_type, parcel_num, ".csv"), header = F)
  
  # map Yeo numbers to parcels
  #make a column of numbers for mapping
  parcelID$network_num <- c(1:dim(parcelID)[1])
  
  #add extra row to parcelID, not clear why this didn't come from Yeo labels, maybe cerebellum?... 8 will equal 65793
  # comment this out if not using yeo 
  parcelID<- rbind(parcelID, c(65793, 8))
  
  #make vector for lh and rh with mapping
  lh_numerical_map <- lh_parcel_nums
  rh_numerical_map <- rh_parcel_nums
  
  #foreach vertex, which contains a bunch of numbers, match it to the appropriate column, and take the network num (i.e. yeo 2, which would correspond to Motor), associated with it
  lh_numerical_map[] <- lapply(lh_parcel_nums, function(x) parcelID$network_num[match(x, parcelID$V1)])
  rh_numerical_map[] <- lapply(rh_parcel_nums, function(x) parcelID$network_num[match(x, parcelID$V1)])

  lh_and_rh_numerical_map_list <- list(lh_numerical_map$V1, rh_numerical_map$V1)
  return(lh_and_rh_numerical_map_list)
  
}

melt_df_for_violin_plot_yeo7 <- function(df, network_names, num_spins){
  #melt dataframe so it is in a good format for violin plotting.
  #melt df so it is in a good position to be plotted
  melted_df_network_name <- rep(x = network_names, each = num_spins)
  melted_df_network_num <- rep(x = seq(1:7), each = num_spins)
  melted_df_spin_results <- rbind(t(df[1,]), 
                                  t(df[2,]),
                                  t(df[3,]),
                                  t(df[4,]),
                                  t(df[5,]),
                                  t(df[6,]),
                                  t(df[7,]))
  
  melted_df <- as.data.frame(cbind(melted_df_network_name, melted_df_network_num,melted_df_spin_results))
  names(melted_df) <- c("network_name", "network_num", "spin")
  melted_df$spin <- as.numeric(as.character(melted_df$spin))
  return(melted_df)
}

violin_plot_pos_and_neg_lines <- function (homedir, models, network_names, num_spins){
  for (model in models) {

    print(model)
    #for storing statistics at the end
    lh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_", model, "_proportions.csv"), sep = ",")
    )
    lh_spin_pos <-data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_pos_", model, "_proportions.csv"), sep = ",")
    )
    lh_spin_neg <-data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_neg_", model, "_proportions.csv"), sep = ",")
    )
    rh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_", model, "_proportions.csv"), sep = ",")
    )
    rh_spin_pos <-data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_pos_", model, "_proportions.csv"), sep = ",")
    )
    rh_spin_neg <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_neg_", model, "_proportions.csv"), sep = ",")
    )
    
    #take means of left and right
    actual_results <- (lh_spin_df[,1] + rh_spin_df[,1])/2
    actual_results_pos <- ((lh_spin_pos[,1] + rh_spin_pos[,1])/2)
    actual_results_neg <- ((lh_spin_neg[,1] + rh_spin_neg[,1])/2)
    
   # print(actual_results)
  #  print(actual_results_pos)
  #  print(actual_results_neg)
    #dataframes for all spins, as well as positive and negative
    spin_without_target_col <- cbind(lh_spin_df[,2:1001],rh_spin_df[,2:1001])
   # print(min(spin_without_target_col))
  #  print(spin_without_target_col[4,5:10])
    
    melted_df <- melt_df_for_violin_plot_yeo7(spin_without_target_col, network_names, num_spins)
  
  #  print(melted_df[1:4,2:3])
    #with mean lines, different fonts
    #save images
    plot_violin <- ggplot(melted_df, aes(x = factor(network_name, level = network_names), y = spin, fill = network_name)) +  
      scale_fill_manual(values=yeo_colors) + 
      geom_violin(trim = TRUE) + 
      xlab("Yeo 7 Network") + ylab(paste0("Proportion")) +
      ylim(0,NA) + 
      geom_violin(trim=FALSE) + 
      theme_classic() + 
      theme(legend.position = "none",
            legend.title = element_blank(),
            axis.text.x = element_text(size = 10, colour = "black"),
            axis.text.y = element_text(size = 10, colour = "black"),
            axis.title.y = element_text(size = 10),
            axis.title.x = element_blank(),
            plot.title = element_text(size = 10)) +
      stat_summary(fun.y = mean, geom = "errorbar", 
                  aes(ymax = ..y.., ymin = ..y.., group = factor(network_name)),
                  width = 0.5, linetype = "dashed", position = position_dodge(0.9)) + 
      geom_segment(aes(x = 0.5, y = actual_results_pos[1], xend = 1.5, yend = actual_results_pos[1]), color="red") + 
      geom_segment(aes(x = 1.5, y = actual_results_pos[2], xend = 2.5, yend = actual_results_pos[2]), color="red") +
      geom_segment(aes(x = 2.5, y = actual_results_pos[3], xend = 3.5, yend = actual_results_pos[3]), color="red") +
      geom_segment(aes(x = 3.5, y = actual_results_pos[4], xend = 4.5, yend = actual_results_pos[4]), color="red") +
      geom_segment(aes(x = 4.5, y = actual_results_pos[5], xend = 5.5, yend = actual_results_pos[5]), color="red") +
      geom_segment(aes(x = 5.5, y = actual_results_pos[6], xend = 6.5, yend = actual_results_pos[6]), color="red") +
      geom_segment(aes(x = 6.5, y = actual_results_pos[7], xend = 7.5, yend = actual_results_pos[7]), color="red") +
      geom_segment(aes(x = 0.5, y = actual_results_neg[1], xend = 1.5, yend = actual_results_neg[1]), color="blue") + 
      geom_segment(aes(x = 1.5, y = actual_results_neg[2], xend = 2.5, yend = actual_results_neg[2]), color="blue") +
      geom_segment(aes(x = 2.5, y = actual_results_neg[3], xend = 3.5, yend = actual_results_neg[3]), color="blue") +
      geom_segment(aes(x = 3.5, y = actual_results_neg[4], xend = 4.5, yend = actual_results_neg[4]), color="blue") +
      geom_segment(aes(x = 4.5, y = actual_results_neg[5], xend = 5.5, yend = actual_results_neg[5]), color="blue") +
      geom_segment(aes(x = 5.5, y = actual_results_neg[6], xend = 6.5, yend = actual_results_neg[6]), color="blue") +
      geom_segment(aes(x = 6.5, y = actual_results_neg[7], xend = 7.5, yend = actual_results_neg[7]), color="blue")
    #  ggtitle(paste0("Spin Test Perm: ", model))
    ggsave(plot=plot_violin, filename = paste0(homedir, "/baller/results/images/spin_", model, "_pos_and_neg_lines_t_fdr05.png"), width = 4.81, height = 4.81)
  }
}

violin_plot_means <- function (homedir, models, network_names, num_spins){
  for (model in models) {
    #for storing statistics at the end
    lh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/lh_spin_test_", model, "_proportions.csv"), sep = ",")
    )
    rh_spin_df <- data.frame(read.table(paste0(homedir, "/baller/results/coupling_accuracy//spin_test_results/rh_spin_test_", model, "_proportions.csv"), sep = ",")
    )
  
    
    #take means of left and right
    actual_results <- (lh_spin_df[,1] + rh_spin_df[,1])/2
    
    #dataframes for all spins
    spin_without_target_col <- cbind(lh_spin_df[,2:1001],rh_spin_df[,2:1001])
    melted_df <- melt_df_for_violin_plot_yeo7(spin_without_target_col, network_names, num_spins)
  
    #with mean lines, different fonts
    #save images
    plot_violin <- ggplot(melted_df, aes(x = factor(network_name, level = network_names), y = spin, fill = network_name)) +  
      scale_fill_manual(values=yeo_colors) + 
      geom_violin(trim = TRUE) + 
      xlab("Yeo 7 Network") + ylab(paste0("Proportion")) +
      geom_violin(trim=FALSE) + 
      ylim(0,NA) + 
      theme_classic() + 
      theme(legend.position = "none",
            legend.title = element_blank(),
            axis.text.x = element_text(size = 10, colour = "black"),
            axis.text.y = element_text(size = 10, colour = "black"),
            axis.title.y = element_text(size = 10),
            axis.title.x = element_blank(),
            plot.title = element_text(size = 10)) +
      stat_summary(fun.y = mean, geom = "errorbar", 
                   aes(ymax = ..y.., ymin = ..y.., group = factor(network_name)),
                   width = 0.5, linetype = "dashed", position = position_dodge(0.9)) + 
      #geom_boxplot(width = 0.15, position = position_dodge(0.9)) + 
        geom_segment(aes(x = 0.5, y = actual_results[1], xend = 1.5, yend = actual_results[1])) + 
        geom_segment(aes(x = 1.5, y = actual_results[2], xend = 2.5, yend = actual_results[2])) +
        geom_segment(aes(x = 2.5, y = actual_results[3], xend = 3.5, yend = actual_results[3])) +
        geom_segment(aes(x = 3.5, y = actual_results[4], xend = 4.5, yend = actual_results[4])) +
        geom_segment(aes(x = 4.5, y = actual_results[5], xend = 5.5, yend = actual_results[5])) +
        geom_segment(aes(x = 5.5, y = actual_results[6], xend = 6.5, yend = actual_results[6])) +
        geom_segment(aes(x = 6.5, y = actual_results[7], xend = 7.5, yend = actual_results[7])) +
  #    ggtitle(paste0("Spin Test Perm: ", model))
    ggsave(plot=plot_violin, filename = paste0(homedir, "/baller/results/images/spin_", model, "_t_fdr05.png"), width = 4.81, height = 4.81)
  }
}

get_yeo7_colors <- function() {
  yeo_colors <- c(
    `VIS` = "#781286",
    `MOT` = "#4682b4",
    `DA` = "#00760e",
    `VA` = "#c43afa",
    `LIM` = "#dcf8a4",
    `FP` = "#e69422",
    `DM` = "#cd3e56")
  return(yeo_colors)
}
```



